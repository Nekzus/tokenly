{"version":3,"file":"index.cjs","sources":["../src/tokenManager.ts","../src/utils/ipHelper.ts"],"sourcesContent":["import crypto from 'crypto';\nimport jwt from 'jsonwebtoken';\n\ninterface TokenlyOptions {\n  secure?: boolean;\n  httpOnly?: boolean;\n  sameSite?: 'strict' | 'lax' | 'none';\n  domain?: string;\n  path?: string;\n  maxAge?: number;\n}\n\ninterface TokenlyConfig {\n  accessTokenExpiry?: string;\n  refreshTokenExpiry?: string;\n  cookieOptions?: TokenlyOptions;\n  jwtOptions?: {\n    algorithm?: jwt.Algorithm;\n    audience?: string | string[];\n    issuer?: string;\n    jwtid?: string;\n    subject?: string;\n    notBefore?: string | number;\n    maxAge?: string | number;\n  };\n  rotationConfig?: {\n    enableAutoRotation?: boolean;\n    rotationInterval?: number;\n    maxRotationCount?: number;\n  };\n  securityConfig?: {\n    enableFingerprint?: boolean;\n    enableBlacklist?: boolean;\n    maxDevices?: number;\n    revokeOnSecurityBreach?: boolean;\n  };\n}\n\ninterface TokenlyToken {\n  iat: number;\n  exp: number;\n  [key: string]: any;\n}\n\ninterface TokenlyResponse {\n  raw: string;\n  payload: {\n    [key: string]: any;\n    iat?: Date;\n    exp?: Date;\n  };\n  cookieConfig?: {\n    name: string;\n    value: string;\n    options: TokenlyOptions;\n  };\n}\n\n/**\n * Tokenly - A secure JWT token manager with HttpOnly cookie support\n * Implements best security practices for JWT token handling in modern web applications\n */\nexport class Tokenly {\n  private secretAccess: string;\n  private secretRefresh: string;\n  private accessTokenExpiry: string;\n  private refreshTokenExpiry: string;\n  private cookieOptions: TokenlyOptions;\n  private jwtOptions: jwt.SignOptions;\n  private verifyOptions: jwt.VerifyOptions;\n  private currentToken: string | null = null;\n  private blacklistedTokens: Set<string> = new Set();\n  private rotationConfig: Required<NonNullable<TokenlyConfig['rotationConfig']>>;\n  private securityConfig: Required<NonNullable<TokenlyConfig['securityConfig']>>;\n  private deviceTokens: Map<string, Set<string>> = new Map();\n  private rotationCounts: Map<string, number> = new Map();\n  private revokedTokens: Set<string> = new Set();\n  private tokenCache: Map<string, TokenlyResponse>;\n  private eventListeners: Map<string, Function[]>;\n  private autoRotationInterval: NodeJS.Timeout | null = null;\n  private fingerprintCache: Map<string, string> = new Map();\n  private readonly instanceSalt: string;\n\n  /**\n   * Initialize Tokenly with custom configuration\n   * @param config Optional configuration for token management\n   */\n  constructor(config?: TokenlyConfig) {\n    this.secretAccess = process.env.JWT_SECRET_ACCESS || 'default-secret-access';\n    this.secretRefresh = process.env.JWT_SECRET_REFRESH || 'default-secret-refresh';\n    this.accessTokenExpiry = config?.accessTokenExpiry || process.env.ACCESS_TOKEN_EXPIRY || '15m';\n    this.refreshTokenExpiry = config?.refreshTokenExpiry || process.env.REFRESH_TOKEN_EXPIRY || '7d';\n\n    // Default secure cookie configuration\n    this.cookieOptions = {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'strict',\n      path: '/',\n      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 días\n      ...config?.cookieOptions,\n    };\n\n    // Default secure JWT configuration\n    this.jwtOptions = {\n      algorithm: 'HS512',\n      issuer: 'tokenly-auth',\n      audience: 'tokenly-client',\n      ...config?.jwtOptions,\n    };\n\n    // Configuración JWT para verificación\n    this.verifyOptions = {\n      algorithms: [this.jwtOptions.algorithm as jwt.Algorithm],\n      issuer: this.jwtOptions.issuer,\n      audience: this.jwtOptions.audience,\n      clockTolerance: 30, // 30 segundos de tolerancia solo para verificación\n    };\n\n    // Configuración de rotación automática\n    this.rotationConfig = {\n      enableAutoRotation: true,\n      rotationInterval: 60, // 60 minutos\n      maxRotationCount: 100,\n      ...config?.rotationConfig,\n    };\n\n    // Configuración de seguridad\n    this.securityConfig = {\n      enableFingerprint: true,\n      enableBlacklist: true,\n      maxDevices: 5,\n      revokeOnSecurityBreach: true,\n      ...config?.securityConfig,\n    };\n\n    this.eventListeners = new Map();\n    this.tokenCache = new Map();\n\n    // Generar un salt único por instancia\n    this.instanceSalt = crypto.randomBytes(32).toString('hex');\n  }\n\n  /**\n   * Format Unix timestamp to ISO date string\n   * @param timestamp Unix timestamp in seconds\n   * @returns ISO 8601 formatted date string\n   */\n  private formatDate(timestamp: number): string {\n    return new Date(timestamp * 1000).toISOString();\n  }\n\n  /**\n   * Decode token and add readable dates\n   * @param token JWT token string\n   * @param decoded Decoded token payload\n   * @param cookieConfig Optional cookie configuration\n   * @returns Formatted token response\n   */\n  private decodeWithReadableDates(\n    token: string,\n    decoded?: any\n  ): TokenlyResponse {\n    if (!decoded) {\n      decoded = jwt.decode(token) as TokenlyToken;\n    }\n\n    const { iat, exp, ...payloadWithoutDates } = decoded;\n    \n    const result: TokenlyResponse = {\n      raw: token,\n      payload: {\n        ...payloadWithoutDates,\n        iat: iat ? this.formatDate(iat) : undefined,\n        exp: exp ? this.formatDate(exp) : undefined,\n      }\n    };\n\n    return result;\n  }\n\n  /**\n   * Genera una huella digital del dispositivo/navegador\n   */\n  private generateFingerprint(context: { userAgent: string; ip: string }): string {\n    if (!context?.userAgent?.trim() || !context?.ip?.trim()) {\n        throw new Error('Invalid or empty context values');\n    }\n\n    // Normalización\n    const normalizedUA = context.userAgent\n        .trim()\n        .toLowerCase()\n        .replace(/\\s+/g, ' ');\n    \n    const normalizedIP = context.ip\n        .trim()\n        .toLowerCase()\n        .replace(/[^0-9.]/g, '');\n\n    // Crear hashes individuales con entropy adicional\n    const uaHash = crypto\n        .createHash('sha256')\n        .update(`ua:${this.instanceSalt}:${normalizedUA}`)\n        .digest('hex');\n    \n    const ipHash = crypto\n        .createHash('sha256')\n        .update(`ip:${this.instanceSalt}:${normalizedIP}`)\n        .digest('hex');\n\n    // Combinar hashes con prefijos para garantizar unicidad\n    const combinedData = `ua=${uaHash}|ip=${ipHash}`;\n\n    // Hash final\n    return crypto\n        .createHash('sha256')\n        .update(combinedData)\n        .digest('hex');\n  }\n\n  /**\n   * Revoca un token específico\n   */\n  public revokeToken(token: string): void {\n    if (!token) return;\n    \n    try {\n      const decoded = jwt.decode(token) as jwt.JwtPayload;\n      this.revokedTokens.add(token);\n      \n      this.emit('tokenRevoked', {\n        token,\n        userId: decoded?.userId,\n        timestamp: Date.now()\n      });\n    } catch (error) {\n      console.error('Error al revocar token:', error);\n    }\n  }\n\n  /**\n   * Verifica si un token está en la lista negra\n   */\n  private isTokenBlacklisted(token: string): boolean {\n    return this.securityConfig.enableBlacklist && this.blacklistedTokens.has(token);\n  }\n\n  private validatePayload(payload: any): void {\n    // Validar que payload sea un objeto\n    if (payload === null || typeof payload !== 'object') {\n      throw new Error('Payload must be an object');\n    }\n    \n    // Validar que no esté vacío\n    if (Object.keys(payload).length === 0) {\n      throw new Error('Payload cannot be empty');\n    }\n\n    // Validar que tenga userId\n    if (!Object.prototype.hasOwnProperty.call(payload, 'userId')) {\n      throw new Error('Payload must contain a userId');\n    }\n    \n    // Validar que userId no sea null o undefined\n    if (payload.userId === null || payload.userId === undefined) {\n      throw new Error('userId cannot be null or undefined');\n    }\n\n    // Validar que userId no esté vacío\n    if (typeof payload.userId !== 'string' || !payload.userId.trim()) {\n      throw new Error('userId cannot be empty');\n    }\n\n    // Validar que ninguna propiedad sea null o undefined\n    Object.entries(payload).forEach(([key, value]) => {\n      if (value === null || value === undefined) {\n        throw new Error(`Payload property '${key}' cannot be null or undefined`);\n      }\n    });\n\n    // Validar tamaño del payload\n    const payloadSize = JSON.stringify(payload).length;\n    if (payloadSize > 8192) {\n      throw new Error('Payload size exceeds maximum allowed size');\n    }\n  }\n\n  /**\n   * Generate a new access token\n   * @param payload Token payload\n   * @param options Optional JWT sign options\n   * @returns Token response with readable dates\n   */\n  generateAccessToken(\n    payload: object,\n    options?: jwt.SignOptions,\n    context?: { userAgent: string; ip: string }\n  ): TokenlyResponse {\n    this.validatePayload(payload);\n    const finalPayload: { [key: string]: any } = { ...payload };\n\n    if (this.securityConfig.enableFingerprint && context) {\n      const fingerprint = this.generateFingerprint(context);\n      const userId = (payload as any).userId;\n      this.handleDeviceStorage(userId, fingerprint);\n      finalPayload.fingerprint = fingerprint;\n    }\n\n    const token = jwt.sign(finalPayload, this.secretAccess, {\n      ...this.jwtOptions,\n      ...options,\n      expiresIn: this.accessTokenExpiry,\n    });\n\n    const response = this.decodeWithReadableDates(token);\n    this.cacheToken(token, response);\n    return response;\n  }\n\n  /**\n   * Verify an access token\n   * @param token JWT token string\n   * @returns Verified token response\n   */\n  public verifyAccessToken(\n    token: string,\n    context?: { userAgent: string; ip: string; additionalData?: string }\n  ): TokenlyResponse {\n    if (this.revokedTokens.has(token) || this.isTokenBlacklisted(token)) {\n      throw new Error('Token has been revoked');\n    }\n\n    const verified = jwt.verify(token, this.secretAccess, {\n      ...this.verifyOptions,\n      ignoreExpiration: false,\n      clockTolerance: 0\n    }) as TokenlyToken;\n\n    if (this.securityConfig.enableFingerprint && context) {\n      const currentFingerprint = this.generateFingerprint(context);\n      if (verified.fingerprint && verified.fingerprint !== currentFingerprint) {\n        throw new Error('Invalid token fingerprint');\n      }\n    }\n\n    const response = this.decodeWithReadableDates(token, verified);\n    this.cacheToken(token, response);\n    return response;\n  }\n\n  /**\n   * Generate a new refresh token with HttpOnly cookie configuration\n   * @param payload Token payload\n   * @param cookieOptions Optional cookie configuration\n   * @returns Token response with cookie configuration\n   */\n  generateRefreshToken(\n    payload: object,\n    cookieOptions?: TokenlyOptions\n  ): TokenlyResponse {\n    this.validatePayload(payload);\n    const finalPayload: { [key: string]: any } = { ...payload };\n    \n    // Eliminar propiedades JWT existentes\n    delete (finalPayload as any).aud;\n    delete (finalPayload as any).iss;\n    delete (finalPayload as any).exp;\n    delete (finalPayload as any).iat;\n\n    const token = jwt.sign(finalPayload, this.secretRefresh, {\n      ...this.jwtOptions,\n      expiresIn: this.refreshTokenExpiry,\n    });\n\n    const response = this.decodeWithReadableDates(token);\n    response.cookieConfig = {\n      name: 'refresh_token',\n      value: token,\n      options: {\n        ...this.cookieOptions,\n        ...cookieOptions,\n      }\n    };\n\n    return response;\n  }\n\n  /**\n   * Verify a refresh token\n   * @param token JWT token string\n   * @returns Verified token response\n   */\n  verifyRefreshToken(token: string): TokenlyResponse {\n    const decoded = jwt.verify(token, this.secretRefresh, this.verifyOptions) as TokenlyToken;\n    return this.decodeWithReadableDates(token, decoded);\n  }\n\n  /**\n   * Rotate access and refresh tokens\n   * @param refreshToken Current refresh token\n   * @param newPayload Optional new payload for the tokens\n   * @returns New access and refresh tokens\n   */\n  rotateTokens(refreshToken: string): {\n    accessToken: TokenlyResponse;\n    refreshToken: TokenlyResponse;\n  } {\n    if (!refreshToken || typeof refreshToken !== 'string') {\n      throw new Error('Invalid refresh token format');\n    }\n\n    const verified = this.verifyRefreshToken(refreshToken);\n    const { iat, exp, aud, iss, ...payload } = verified.payload;\n\n    // Verificar límite de rotaciones\n    const tokenId = refreshToken;\n    const currentCount = this.rotationCounts.get(tokenId) || 0;\n    \n    if (currentCount >= (this.rotationConfig.maxRotationCount || 2)) {\n      throw new Error('Maximum rotation count exceeded');\n    }\n    \n    this.rotationCounts.set(tokenId, currentCount + 1);\n\n    return {\n      accessToken: this.generateAccessToken(payload),\n      refreshToken: this.generateRefreshToken(payload)\n    };\n  }\n\n  /**\n   * Store a token\n   * @param token Token string to store\n   */\n  setToken(token: string): void {\n    this.currentToken = token;\n  }\n\n  /**\n   * Retrieve the stored token\n   * @returns The stored token or null if none exists\n   */\n  getToken(): string | null {\n    return this.currentToken;\n  }\n\n  /**\n   * Clear the stored token\n   */\n  clearToken(): void {\n    this.currentToken = null;\n  }\n\n  /**\n   * Helper para verificar si un token está próximo a expirar\n   * @param token Token a verificar\n   * @param thresholdMinutes Minutos antes de la expiración para considerar como \"próximo a expirar\"\n   */\n  public isTokenExpiringSoon(token: string, thresholdMinutes: number = 5): boolean {\n    try {\n      const decoded = jwt.decode(token) as jwt.JwtPayload;\n      if (!decoded || !decoded.exp) return false;\n\n      const expirationTime = decoded.exp * 1000;\n      const currentTime = Date.now();\n      const timeUntilExpiry = expirationTime - currentTime;\n      \n      return timeUntilExpiry < (thresholdMinutes * 60 * 1000);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Helper para obtener información del token de forma segura\n   * @param token Token a decodificar\n   */\n  public getTokenInfo(token: string): TokenInfo | null {\n    try {\n      const decoded = jwt.decode(token) as jwt.JwtPayload;\n      if (!decoded) return null;\n\n      return {\n        userId: decoded.userId as string,\n        expiresAt: new Date(decoded.exp! * 1000),\n        issuedAt: new Date(decoded.iat! * 1000),\n        fingerprint: decoded.fingerprint as string | undefined\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Validar un token sin verificar la firma (útil para pre-validaciones)\n   * @param token Token a validar\n   */\n  public validateTokenFormat(token: string): boolean {\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) return false;\n\n      return parts.every(part => {\n        try {\n          Buffer.from(part, 'base64').toString();\n          return true;\n        } catch {\n          return false;\n        }\n      });\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Generar un token temporal de un solo uso\n   * @param purpose Propósito del token\n   * @param expiresIn Tiempo de expiración\n   */\n  public generateOneTimeToken(purpose: string, expiresIn: string = '5m'): string {\n    const payload = {\n      purpose,\n      nonce: crypto.randomBytes(16).toString('hex'),\n      iat: Math.floor(Date.now() / 1000)\n    };\n\n    return jwt.sign(payload, this.secretAccess, { expiresIn });\n  }\n\n  /**\n   * Validar un refresh token con verificaciones adicionales de seguridad\n   */\n  public verifyRefreshTokenEnhanced(token: string): TokenlyResponse {\n    if (!this.validateTokenFormat(token)) {\n      throw new Error('Invalid token format');\n    }\n\n    const verified = this.verifyRefreshToken(token);\n    \n    if (this.isTokenExpiringSoon(token, 60)) {\n      throw new Error('Refresh token is about to expire');\n    }\n\n    return verified;\n  }\n\n  // Sistema de eventos\n  public on(event: string, callback: Function): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event)?.push(callback);\n  }\n\n  private emit(event: string, data: any): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners?.length) {\n      listeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          // Silent error handling for callbacks\n        }\n      });\n    }\n  }\n\n  // Sistema de caché con auto-limpieza\n  private cacheToken(key: string, value: TokenlyResponse): void {\n    this.tokenCache.set(key, value);\n    \n    // Auto-limpieza después de 5 minutos\n    setTimeout(() => {\n      this.tokenCache.delete(key);\n    }, 5 * 60 * 1000);\n  }\n\n  // Análisis de seguridad del token\n  public analyzeTokenSecurity(token: string): TokenSecurityAnalysis {\n    const decoded = jwt.decode(token, { complete: true }) as { \n      header: { alg: string }, \n      payload: TokenlyToken & { fingerprint?: string } \n    };\n    if (!decoded) throw new Error('Invalid token');\n\n    return {\n      algorithm: decoded.header.alg,\n      hasFingerprint: !!decoded.payload.fingerprint,\n      expirationTime: new Date(decoded.payload.exp * 1000),\n      issuedAt: new Date(decoded.payload.iat * 1000),\n      timeUntilExpiry: (decoded.payload.exp * 1000) - Date.now(),\n      strength: this.calculateTokenStrength(decoded)\n    };\n  }\n\n  // Calcular la fortaleza del token\n  private calculateTokenStrength(decodedToken: any): 'weak' | 'medium' | 'strong' {\n    let score = 0;\n    \n    // Verificar algoritmo\n    if (decodedToken.header.alg === 'HS512') score += 2;\n    else if (decodedToken.header.alg === 'HS256') score += 1;\n    \n    // Verificar fingerprint\n    if (decodedToken.payload.fingerprint) score += 2;\n    \n    // Verificar tiempo de expiración\n    const timeUntilExpiry = (decodedToken.payload.exp * 1000) - Date.now();\n    if (timeUntilExpiry < 15 * 60 * 1000) score += 1; // < 15 minutos\n    else if (timeUntilExpiry < 60 * 60 * 1000) score += 2; // < 1 hora\n    \n    return score <= 2 ? 'weak' : score <= 4 ? 'medium' : 'strong';\n  }\n\n  // Rotación automática de tokens\n  public enableAutoRotation(options: AutoRotationOptions = {}): NodeJS.Timeout {\n    console.log('Enabling auto rotation...');\n    const {\n      checkInterval = 50,\n      rotateBeforeExpiry = 1000\n    } = options;\n\n    if (this.autoRotationInterval) {\n      clearInterval(this.autoRotationInterval);\n    }\n\n    // Ejecutar verificación inmediata\n    this.checkTokensExpiration(rotateBeforeExpiry);\n\n    // Configurar nuevo intervalo\n    this.autoRotationInterval = setInterval(() => {\n      this.checkTokensExpiration(rotateBeforeExpiry);\n    }, checkInterval);\n\n    return this.autoRotationInterval;\n  }\n\n  // Método para detener la auto-rotación\n  public disableAutoRotation(): void {\n    if (this.autoRotationInterval) {\n      clearInterval(this.autoRotationInterval);\n      this.autoRotationInterval = null;\n    }\n  }\n\n  private checkTokensExpiration(rotateBeforeExpiry: number): void {\n    Array.from(this.tokenCache.entries()).forEach(([token, _]) => {\n      try {\n        const decoded = jwt.decode(token) as jwt.JwtPayload;\n        if (decoded?.exp) {\n          const timeUntilExpiry = (decoded.exp * 1000) - Date.now();\n          if (timeUntilExpiry < rotateBeforeExpiry) {\n            this.emit('tokenExpiring', {\n              token,\n              userId: decoded.userId,\n              expiresIn: timeUntilExpiry\n            });\n          }\n        }\n      } catch (error) {\n        // Silent error handling for token checks\n      }\n    });\n  }\n\n  // Limpieza automática de tokens revocados\n  public enableAutoCleanup(interval: number = 3600000): void { // 1 hora por defecto\n    setInterval(() => {\n      const now = Date.now();\n      this.revokedTokens.forEach(token => {\n        try {\n          const decoded = jwt.decode(token) as jwt.JwtPayload;\n          if (decoded && decoded.exp && decoded.exp * 1000 < now) {\n            this.revokedTokens.delete(token);\n          }\n        } catch {\n          // Token inválido, eliminarlo\n          this.revokedTokens.delete(token);\n        }\n      });\n    }, interval);\n  }\n\n  private handleDeviceStorage(userId: string, fingerprint: string): void {\n    if (!this.deviceTokens.has(userId)) {\n      this.deviceTokens.set(userId, new Set());\n    }\n\n    const userDevices = this.deviceTokens.get(userId)!;\n    const deviceKey = `${userId}:${fingerprint}`;\n\n    if (!this.fingerprintCache.has(deviceKey)) {\n      if (userDevices.size >= this.securityConfig.maxDevices) {\n        throw new Error('Maximum number of devices reached');\n      }\n      this.fingerprintCache.set(deviceKey, fingerprint);\n    }\n\n    userDevices.add(fingerprint);\n  }\n}\n\n// Tipos adicionales\ninterface TokenInfo {\n  userId: string;\n  expiresAt: Date;\n  issuedAt: Date;\n  fingerprint?: string;\n}\n\ninterface TokenSecurityAnalysis {\n  algorithm: string;\n  hasFingerprint: boolean;\n  expirationTime: Date;\n  issuedAt: Date;\n  timeUntilExpiry: number;\n  strength: 'weak' | 'medium' | 'strong';\n}\n\ninterface AutoRotationOptions {\n  checkInterval?: number;\n  rotateBeforeExpiry?: number;\n}","/**\n * Helper function to get the real client IP from various headers\n * @param headers Object containing HTTP headers\n * @returns string Client IP address\n */\nexport function getClientIP(headers: Record<string, string | string[] | undefined>, defaultIP?: string): string {\n    // Intentar X-Real-IP primero\n    const realIP = headers['x-real-ip'];\n    if (typeof realIP === 'string' && realIP.trim()) {\n        return realIP.trim();\n    }\n\n    // Fallback a X-Forwarded-For si está disponible\n    const forwardedFor = headers['x-forwarded-for'];\n    if (typeof forwardedFor === 'string' && forwardedFor.trim()) {\n        return forwardedFor.split(',')[0].trim();\n    }\n\n    // Último fallback a IP proporcionada o vacía\n    return defaultIP || '';\n} "],"names":["constructor","config","this","currentToken","blacklistedTokens","Set","deviceTokens","Map","rotationCounts","revokedTokens","autoRotationInterval","fingerprintCache","secretAccess","process","env","JWT_SECRET_ACCESS","secretRefresh","JWT_SECRET_REFRESH","accessTokenExpiry","ACCESS_TOKEN_EXPIRY","refreshTokenExpiry","REFRESH_TOKEN_EXPIRY","cookieOptions","httpOnly","secure","NODE_ENV","sameSite","path","maxAge","jwtOptions","algorithm","issuer","audience","verifyOptions","algorithms","clockTolerance","rotationConfig","enableAutoRotation","rotationInterval","maxRotationCount","securityConfig","enableFingerprint","enableBlacklist","maxDevices","revokeOnSecurityBreach","eventListeners","tokenCache","instanceSalt","crypto","randomBytes","toString","formatDate","timestamp","Date","toISOString","decodeWithReadableDates","token","decoded","jwt","decode","iat","exp","payloadWithoutDates","raw","payload","undefined","generateFingerprint","context","userAgent","trim","ip","Error","normalizedUA","toLowerCase","replace","normalizedIP","combinedData","createHash","update","digest","revokeToken","add","emit","userId","now","error","console","isTokenBlacklisted","has","validatePayload","Object","keys","length","prototype","hasOwnProperty","call","entries","forEach","key","value","JSON","stringify","generateAccessToken","options","finalPayload","fingerprint","handleDeviceStorage","sign","expiresIn","response","cacheToken","verifyAccessToken","verified","verify","ignoreExpiration","currentFingerprint","generateRefreshToken","aud","iss","cookieConfig","name","verifyRefreshToken","rotateTokens","refreshToken","tokenId","currentCount","get","set","accessToken","setToken","getToken","clearToken","isTokenExpiringSoon","thresholdMinutes","expirationTime","currentTime","getTokenInfo","expiresAt","issuedAt","validateTokenFormat","parts","split","every","part","Buffer","from","generateOneTimeToken","purpose","nonce","Math","floor","verifyRefreshTokenEnhanced","on","event","callback","push","data","listeners","setTimeout","delete","analyzeTokenSecurity","complete","header","alg","hasFingerprint","timeUntilExpiry","strength","calculateTokenStrength","decodedToken","score","log","checkInterval","rotateBeforeExpiry","clearInterval","checkTokensExpiration","setInterval","disableAutoRotation","Array","_","enableAutoCleanup","interval","userDevices","deviceKey","size","headers","defaultIP","realIP","forwardedFor"],"mappings":"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"}