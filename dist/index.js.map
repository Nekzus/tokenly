{"version":3,"file":"index.js","sources":["../src/tokenManager.ts"],"sourcesContent":["import crypto from 'crypto';\nimport jwt from 'jsonwebtoken';\n\ninterface TokenlyOptions {\n  secure?: boolean;\n  httpOnly?: boolean;\n  sameSite?: 'strict' | 'lax' | 'none';\n  domain?: string;\n  path?: string;\n  maxAge?: number;\n}\n\ninterface TokenlyConfig {\n  accessTokenExpiry?: string;\n  refreshTokenExpiry?: string;\n  cookieOptions?: TokenlyOptions;\n  jwtOptions?: {\n    algorithm?: jwt.Algorithm;\n    audience?: string | string[];\n    issuer?: string;\n    jwtid?: string;\n    subject?: string;\n    notBefore?: string | number;\n    maxAge?: string | number;\n  };\n  rotationConfig?: {\n    enableAutoRotation?: boolean;\n    rotationInterval?: number;\n    maxRotationCount?: number;\n  };\n  securityConfig?: {\n    enableFingerprint?: boolean;\n    enableBlacklist?: boolean;\n    maxDevices?: number;\n    revokeOnSecurityBreach?: boolean;\n  };\n}\n\ninterface TokenlyToken {\n  iat: number;\n  exp: number;\n  [key: string]: any;\n}\n\ninterface TokenlyResponse {\n  raw: string;\n  payload: {\n    [key: string]: any;\n    iat?: Date;\n    exp?: Date;\n  };\n  cookieConfig?: {\n    name: string;\n    value: string;\n    options: TokenlyOptions;\n  };\n}\n\n/**\n * Tokenly - A secure JWT token manager with HttpOnly cookie support\n * Implements best security practices for JWT token handling in modern web applications\n */\nexport class Tokenly {\n  private secretAccess: string;\n  private secretRefresh: string;\n  private accessTokenExpiry: string;\n  private refreshTokenExpiry: string;\n  private cookieOptions: TokenlyOptions;\n  private jwtOptions: jwt.SignOptions;\n  private verifyOptions: jwt.VerifyOptions;\n  private currentToken: string | null = null;\n  private blacklistedTokens: Set<string> = new Set();\n  private rotationConfig: Required<NonNullable<TokenlyConfig['rotationConfig']>>;\n  private securityConfig: Required<NonNullable<TokenlyConfig['securityConfig']>>;\n  private deviceTokens: Map<string, Set<string>> = new Map();\n  private rotationCounts: Map<string, number> = new Map();\n  private revokedTokens: Set<string> = new Set();\n  private tokenCache: Map<string, TokenlyResponse>;\n  private eventListeners: Map<string, Function[]>;\n  private autoRotationInterval: NodeJS.Timeout | null = null;\n\n  /**\n   * Initialize Tokenly with custom configuration\n   * @param config Optional configuration for token management\n   */\n  constructor(config?: TokenlyConfig) {\n    this.secretAccess = process.env.JWT_SECRET_ACCESS || 'default-secret-access';\n    this.secretRefresh = process.env.JWT_SECRET_REFRESH || 'default-secret-refresh';\n    this.accessTokenExpiry = config?.accessTokenExpiry || process.env.ACCESS_TOKEN_EXPIRY || '15m';\n    this.refreshTokenExpiry = config?.refreshTokenExpiry || process.env.REFRESH_TOKEN_EXPIRY || '7d';\n\n    // Default secure cookie configuration\n    this.cookieOptions = {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'strict',\n      path: '/',\n      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 días\n      ...config?.cookieOptions,\n    };\n\n    // Default secure JWT configuration\n    this.jwtOptions = {\n      algorithm: 'HS512',\n      issuer: 'tokenly-auth',\n      audience: 'tokenly-client',\n      ...config?.jwtOptions,\n    };\n\n    // Configuración JWT para verificación\n    this.verifyOptions = {\n      algorithms: [this.jwtOptions.algorithm as jwt.Algorithm],\n      issuer: this.jwtOptions.issuer,\n      audience: this.jwtOptions.audience,\n      clockTolerance: 30, // 30 segundos de tolerancia solo para verificación\n    };\n\n    // Configuración de rotación automática\n    this.rotationConfig = {\n      enableAutoRotation: true,\n      rotationInterval: 60, // 60 minutos\n      maxRotationCount: 100,\n      ...config?.rotationConfig,\n    };\n\n    // Configuración de seguridad\n    this.securityConfig = {\n      enableFingerprint: true,\n      enableBlacklist: true,\n      maxDevices: 5,\n      revokeOnSecurityBreach: true,\n      ...config?.securityConfig,\n    };\n\n    this.eventListeners = new Map();\n    this.tokenCache = new Map();\n  }\n\n  /**\n   * Format Unix timestamp to ISO date string\n   * @param timestamp Unix timestamp in seconds\n   * @returns ISO 8601 formatted date string\n   */\n  private formatDate(timestamp: number): string {\n    return new Date(timestamp * 1000).toISOString();\n  }\n\n  /**\n   * Decode token and add readable dates\n   * @param token JWT token string\n   * @param decoded Decoded token payload\n   * @param cookieConfig Optional cookie configuration\n   * @returns Formatted token response\n   */\n  private decodeWithReadableDates(\n    token: string,\n    decoded?: any\n  ): TokenlyResponse {\n    if (!decoded) {\n      decoded = jwt.decode(token) as TokenlyToken;\n    }\n\n    const { iat, exp, ...payloadWithoutDates } = decoded;\n    \n    const result: TokenlyResponse = {\n      raw: token,\n      payload: {\n        ...payloadWithoutDates,\n        iat: iat ? new Date(iat * 1000) : undefined,\n        exp: exp ? new Date(exp * 1000) : undefined,\n      }\n    };\n\n    return result;\n  }\n\n  /**\n   * Genera una huella digital del dispositivo/navegador\n   */\n  private generateFingerprint(context: { userAgent: string; ip: string; additionalData?: string }): string {\n    if (!context.userAgent || !context.ip) {\n        throw new Error('User agent and IP are required for fingerprint generation');\n    }\n\n    // Limpiar las comillas extras del input\n    const cleanUserAgent = context.userAgent.replace(/^\"|\"$/g, '');\n    const cleanIP = context.ip.replace(/^\"|\"$/g, '');\n\n    // Crear un objeto base con la información normalizada del contexto\n    const baseFingerprint = {\n        ua: cleanUserAgent,\n        ip: cleanIP,\n        // Mantener información de longitud original para detectar cambios sutiles\n        uaLength: cleanUserAgent.length,\n        ipLength: cleanIP.length,\n        // Añadir segmentos de IP para mayor entropía\n        ipSegments: cleanIP.split('.').join(''),\n        // Timestamp para unicidad\n        timestamp: Date.now(),\n        // Datos adicionales si existen\n        additional: context.additionalData || ''\n    };\n\n    // Generar una cadena única combinando todos los elementos\n    const fingerprintStr = JSON.stringify(baseFingerprint);\n\n    // Generar hash SHA-256\n    const hash = crypto\n        .createHash('sha256')\n        .update(fingerprintStr, 'utf8')\n        .digest('hex');\n\n    // Debug logs para rastreo\n    console.log('DEBUG generateFingerprint - Cleaned Input:', {\n        userAgent: cleanUserAgent,\n        ip: cleanIP,\n        additionalData: context.additionalData\n    });\n\n    return hash;\n  }\n\n  /**\n   * Revoca un token específico\n   */\n  public revokeToken(token: string): void {\n    if (!token) return;\n    \n    try {\n      const decoded = jwt.decode(token) as jwt.JwtPayload;\n      this.revokedTokens.add(token);\n      \n      this.emit('tokenRevoked', {\n        token,\n        userId: decoded?.userId,\n        timestamp: Date.now()\n      });\n    } catch (error) {\n      console.error('Error al revocar token:', error);\n    }\n  }\n\n  /**\n   * Verifica si un token está en la lista negra\n   */\n  private isTokenBlacklisted(token: string): boolean {\n    return this.securityConfig.enableBlacklist && this.blacklistedTokens.has(token);\n  }\n\n  private validatePayload(payload: any): void {\n    // Validar que payload sea un objeto\n    if (payload === null || typeof payload !== 'object') {\n      throw new Error('Payload must be an object');\n    }\n    \n    // Validar que no esté vacío\n    if (Object.keys(payload).length === 0) {\n      throw new Error('Payload cannot be empty');\n    }\n\n    // Validar que tenga userId\n    if (!Object.prototype.hasOwnProperty.call(payload, 'userId')) {\n      throw new Error('Payload must contain a userId');\n    }\n    \n    // Validar que userId no sea null o undefined\n    if (payload.userId === null || payload.userId === undefined) {\n      throw new Error('userId cannot be null or undefined');\n    }\n\n    // Validar que userId no esté vacío\n    if (typeof payload.userId !== 'string' || !payload.userId.trim()) {\n      throw new Error('userId cannot be empty');\n    }\n\n    // Validar que ninguna propiedad sea null o undefined\n    Object.entries(payload).forEach(([key, value]) => {\n      if (value === null || value === undefined) {\n        throw new Error(`Payload property '${key}' cannot be null or undefined`);\n      }\n    });\n\n    // Validar tamaño del payload\n    const payloadSize = JSON.stringify(payload).length;\n    if (payloadSize > 8192) {\n      throw new Error('Payload size exceeds maximum allowed size');\n    }\n  }\n\n  /**\n   * Generate a new access token\n   * @param payload Token payload\n   * @param options Optional JWT sign options\n   * @returns Token response with readable dates\n   */\n  generateAccessToken(\n    payload: object,\n    options?: jwt.SignOptions,\n    context?: { userAgent: string; ip: string; additionalData?: string }\n  ): TokenlyResponse {\n    this.validatePayload(payload);\n    const finalPayload: { [key: string]: any } = { ...payload };\n\n    if (this.securityConfig.enableFingerprint && context) {\n      const fingerprint = this.generateFingerprint(context);\n      const userId = (payload as any).userId;\n      \n      if (!this.deviceTokens.has(userId)) {\n        this.deviceTokens.set(userId, new Set());\n      }\n      \n      const userDevices = this.deviceTokens.get(userId)!;\n      if (userDevices.size >= this.securityConfig.maxDevices && !userDevices.has(fingerprint)) {\n        throw new Error('Maximum number of devices reached');\n      }\n      \n      userDevices.add(fingerprint);\n      finalPayload.fingerprint = fingerprint;\n    }\n\n    const token = jwt.sign(finalPayload, this.secretAccess, {\n      ...this.jwtOptions,\n      ...options,\n      expiresIn: this.accessTokenExpiry,\n    });\n\n    const response = this.decodeWithReadableDates(token);\n    this.tokenCache.set(token, response);\n    return response;\n  }\n\n  /**\n   * Verify an access token\n   * @param token JWT token string\n   * @returns Verified token response\n   */\n  public verifyAccessToken(\n    token: string,\n    context?: { userAgent: string; ip: string; additionalData?: string }\n  ): TokenlyResponse {\n    console.log('DEBUG verifyAccessToken - Start');\n    console.log('DEBUG verifyAccessToken - Raw Context:', {\n      userAgent: context?.userAgent ? `\"${context.userAgent}\"` : undefined,\n      ip: context?.ip ? `\"${context.ip}\"` : undefined,\n      additionalData: context?.additionalData\n    });\n\n    if (this.revokedTokens.has(token)) {\n      throw new Error('Token has been revoked');\n    }\n\n    const verified = jwt.verify(token, this.secretAccess, {\n      ...this.verifyOptions,\n      ignoreExpiration: false,\n      clockTolerance: 0\n    }) as TokenlyToken;\n\n    if (this.securityConfig.enableFingerprint && context) {\n      const storedFingerprint = verified.fingerprint;\n      console.log('DEBUG verifyAccessToken - Stored Fingerprint:', storedFingerprint);\n\n      const currentFingerprint = this.generateFingerprint(context);\n      console.log('DEBUG verifyAccessToken - Generated Fingerprint:', currentFingerprint);\n\n      if (storedFingerprint !== currentFingerprint) {\n        console.log('DEBUG verifyAccessToken - Fingerprint Mismatch Details:', {\n          stored: storedFingerprint,\n          current: currentFingerprint,\n          storedContext: verified.fingerprintContext,\n          currentContext: context\n        });\n        throw new Error('Invalid token fingerprint');\n      }\n    }\n\n    const response = this.decodeWithReadableDates(token, verified);\n    this.tokenCache.set(token, response);\n    return response;\n  }\n\n  /**\n   * Generate a new refresh token with HttpOnly cookie configuration\n   * @param payload Token payload\n   * @param cookieOptions Optional cookie configuration\n   * @returns Token response with cookie configuration\n   */\n  generateRefreshToken(\n    payload: object,\n    cookieOptions?: TokenlyOptions\n  ): TokenlyResponse {\n    this.validatePayload(payload);\n    const finalPayload: { [key: string]: any } = { ...payload };\n    \n    // Eliminar propiedades JWT existentes\n    delete (finalPayload as any).aud;\n    delete (finalPayload as any).iss;\n    delete (finalPayload as any).exp;\n    delete (finalPayload as any).iat;\n\n    const token = jwt.sign(finalPayload, this.secretRefresh, {\n      ...this.jwtOptions,\n      expiresIn: this.refreshTokenExpiry,\n    });\n\n    const response = this.decodeWithReadableDates(token);\n    response.cookieConfig = {\n      name: 'refresh_token',\n      value: token,\n      options: {\n        ...this.cookieOptions,\n        ...cookieOptions,\n      }\n    };\n\n    return response;\n  }\n\n  /**\n   * Verify a refresh token\n   * @param token JWT token string\n   * @returns Verified token response\n   */\n  verifyRefreshToken(token: string): TokenlyResponse {\n    const decoded = jwt.verify(token, this.secretRefresh, this.verifyOptions) as TokenlyToken;\n    return this.decodeWithReadableDates(token, decoded);\n  }\n\n  /**\n   * Rotate access and refresh tokens\n   * @param refreshToken Current refresh token\n   * @param newPayload Optional new payload for the tokens\n   * @returns New access and refresh tokens\n   */\n  rotateTokens(refreshToken: string): {\n    accessToken: TokenlyResponse;\n    refreshToken: TokenlyResponse;\n  } {\n    if (!refreshToken || typeof refreshToken !== 'string') {\n      throw new Error('Invalid refresh token format');\n    }\n\n    const verified = this.verifyRefreshToken(refreshToken);\n    const { iat, exp, aud, iss, ...payload } = verified.payload;\n\n    // Verificar límite de rotaciones\n    const tokenId = refreshToken;\n    const currentCount = this.rotationCounts.get(tokenId) || 0;\n    \n    if (currentCount >= (this.rotationConfig.maxRotationCount || 2)) {\n      throw new Error('Maximum rotation count exceeded');\n    }\n    \n    this.rotationCounts.set(tokenId, currentCount + 1);\n\n    return {\n      accessToken: this.generateAccessToken(payload),\n      refreshToken: this.generateRefreshToken(payload)\n    };\n  }\n\n  /**\n   * Store a token\n   * @param token Token string to store\n   */\n  setToken(token: string): void {\n    this.currentToken = token;\n  }\n\n  /**\n   * Retrieve the stored token\n   * @returns The stored token or null if none exists\n   */\n  getToken(): string | null {\n    return this.currentToken;\n  }\n\n  /**\n   * Clear the stored token\n   */\n  clearToken(): void {\n    this.currentToken = null;\n  }\n\n  /**\n   * Helper para verificar si un token está próximo a expirar\n   * @param token Token a verificar\n   * @param thresholdMinutes Minutos antes de la expiración para considerar como \"próximo a expirar\"\n   */\n  public isTokenExpiringSoon(token: string, thresholdMinutes: number = 5): boolean {\n    try {\n      const decoded = jwt.decode(token) as jwt.JwtPayload;\n      if (!decoded || !decoded.exp) return false;\n\n      const expirationTime = decoded.exp * 1000;\n      const currentTime = Date.now();\n      const timeUntilExpiry = expirationTime - currentTime;\n      \n      return timeUntilExpiry < (thresholdMinutes * 60 * 1000);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Helper para obtener información del token de forma segura\n   * @param token Token a decodificar\n   */\n  public getTokenInfo(token: string): TokenInfo | null {\n    try {\n      const decoded = jwt.decode(token) as jwt.JwtPayload;\n      if (!decoded) return null;\n\n      return {\n        userId: decoded.userId as string,\n        expiresAt: new Date(decoded.exp! * 1000),\n        issuedAt: new Date(decoded.iat! * 1000),\n        fingerprint: decoded.fingerprint as string | undefined\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Validar un token sin verificar la firma (útil para pre-validaciones)\n   * @param token Token a validar\n   */\n  public validateTokenFormat(token: string): boolean {\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) return false;\n\n      return parts.every(part => {\n        try {\n          Buffer.from(part, 'base64').toString();\n          return true;\n        } catch {\n          return false;\n        }\n      });\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Generar un token temporal de un solo uso\n   * @param purpose Propósito del token\n   * @param expiresIn Tiempo de expiración\n   */\n  public generateOneTimeToken(purpose: string, expiresIn: string = '5m'): string {\n    const payload = {\n      purpose,\n      nonce: crypto.randomBytes(16).toString('hex'),\n      iat: Math.floor(Date.now() / 1000)\n    };\n\n    return jwt.sign(payload, this.secretAccess, { expiresIn });\n  }\n\n  /**\n   * Mejorar la seguridad de las cookies con flags adicionales\n   */\n  private getEnhancedCookieOptions(): CookieOptions {\n    return {\n      ...this.cookieOptions,\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'strict' as const,\n      path: '/',\n      expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),\n      maxAge: 7 * 24 * 60 * 60 * 1000\n    };\n  }\n\n  /**\n   * Validar un refresh token con verificaciones adicionales de seguridad\n   */\n  public verifyRefreshTokenEnhanced(token: string): TokenlyResponse {\n    if (!this.validateTokenFormat(token)) {\n      throw new Error('Invalid token format');\n    }\n\n    const verified = this.verifyRefreshToken(token);\n    \n    if (this.isTokenExpiringSoon(token, 60)) {\n      throw new Error('Refresh token is about to expire');\n    }\n\n    return verified;\n  }\n\n  // Sistema de eventos\n  public on(event: string, callback: Function): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event)?.push(callback);\n  }\n\n  private emit(event: string, data: any): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners?.length) {\n      listeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          // Silent error handling for callbacks\n        }\n      });\n    }\n  }\n\n  // Sistema de caché con auto-limpieza\n  private cacheToken(key: string, value: TokenlyResponse): void {\n    this.tokenCache.set(key, value);\n    \n    // Auto-limpieza después de 5 minutos\n    setTimeout(() => {\n      this.tokenCache.delete(key);\n    }, 5 * 60 * 1000);\n  }\n\n  // Análisis de seguridad del token\n  public analyzeTokenSecurity(token: string): TokenSecurityAnalysis {\n    const decoded = jwt.decode(token, { complete: true }) as { \n      header: { alg: string }, \n      payload: TokenlyToken & { fingerprint?: string } \n    };\n    if (!decoded) throw new Error('Invalid token');\n\n    return {\n      algorithm: decoded.header.alg,\n      hasFingerprint: !!decoded.payload.fingerprint,\n      expirationTime: new Date(decoded.payload.exp * 1000),\n      issuedAt: new Date(decoded.payload.iat * 1000),\n      timeUntilExpiry: (decoded.payload.exp * 1000) - Date.now(),\n      strength: this.calculateTokenStrength(decoded)\n    };\n  }\n\n  // Calcular la fortaleza del token\n  private calculateTokenStrength(decodedToken: any): 'weak' | 'medium' | 'strong' {\n    let score = 0;\n    \n    // Verificar algoritmo\n    if (decodedToken.header.alg === 'HS512') score += 2;\n    else if (decodedToken.header.alg === 'HS256') score += 1;\n    \n    // Verificar fingerprint\n    if (decodedToken.payload.fingerprint) score += 2;\n    \n    // Verificar tiempo de expiración\n    const timeUntilExpiry = (decodedToken.payload.exp * 1000) - Date.now();\n    if (timeUntilExpiry < 15 * 60 * 1000) score += 1; // < 15 minutos\n    else if (timeUntilExpiry < 60 * 60 * 1000) score += 2; // < 1 hora\n    \n    return score <= 2 ? 'weak' : score <= 4 ? 'medium' : 'strong';\n  }\n\n  // Rotación automática de tokens\n  public enableAutoRotation(options: AutoRotationOptions = {}): NodeJS.Timeout {\n    console.log('Enabling auto rotation...');\n    const {\n      checkInterval = 50,\n      rotateBeforeExpiry = 1000\n    } = options;\n\n    if (this.autoRotationInterval) {\n      clearInterval(this.autoRotationInterval);\n    }\n\n    // Ejecutar verificación inmediata\n    this.checkTokensExpiration(rotateBeforeExpiry);\n\n    // Configurar nuevo intervalo\n    this.autoRotationInterval = setInterval(() => {\n      this.checkTokensExpiration(rotateBeforeExpiry);\n    }, checkInterval);\n\n    return this.autoRotationInterval;\n  }\n\n  // Método para detener la auto-rotación\n  public disableAutoRotation(): void {\n    if (this.autoRotationInterval) {\n      clearInterval(this.autoRotationInterval);\n      this.autoRotationInterval = null;\n    }\n  }\n\n  private checkTokensExpiration(rotateBeforeExpiry: number): void {\n    Array.from(this.tokenCache.entries()).forEach(([token, _]) => {\n      try {\n        const decoded = jwt.decode(token) as jwt.JwtPayload;\n        if (decoded?.exp) {\n          const timeUntilExpiry = (decoded.exp * 1000) - Date.now();\n          if (timeUntilExpiry < rotateBeforeExpiry) {\n            this.emit('tokenExpiring', {\n              token,\n              userId: decoded.userId,\n              expiresIn: timeUntilExpiry\n            });\n          }\n        }\n      } catch (error) {\n        // Silent error handling for token checks\n      }\n    });\n  }\n\n  // Limpieza automática de tokens revocados\n  public enableAutoCleanup(interval: number = 3600000): void { // 1 hora por defecto\n    setInterval(() => {\n      const now = Date.now();\n      this.revokedTokens.forEach(token => {\n        try {\n          const decoded = jwt.decode(token) as jwt.JwtPayload;\n          if (decoded && decoded.exp && decoded.exp * 1000 < now) {\n            this.revokedTokens.delete(token);\n          }\n        } catch {\n          // Token inválido, eliminarlo\n          this.revokedTokens.delete(token);\n        }\n      });\n    }, interval);\n  }\n\n  private findTokenByFingerprint(fingerprint: string): string | null {\n    for (const [, devices] of this.deviceTokens.entries()) {\n      if (devices.has(fingerprint)) {\n        return this.getToken();\n      }\n    }\n    return null;\n  }\n\n  private async validateDeviceLimit(userId: string, fingerprint: string): Promise<void> {\n    if (!this.deviceTokens.has(userId)) {\n      this.deviceTokens.set(userId, new Set());\n    }\n\n    const userDevices = this.deviceTokens.get(userId)!;\n    \n    if (userDevices.size >= this.securityConfig.maxDevices && !userDevices.has(fingerprint)) {\n      this.emit('maxDevicesReached', {\n        userId,\n        currentDevices: Array.from(userDevices),\n        maxDevices: this.securityConfig.maxDevices\n      });\n      throw new Error('Maximum number of devices reached');\n    }\n    \n    userDevices.add(fingerprint);\n  }\n}\n\n// Tipos adicionales\ninterface TokenInfo {\n  userId: string;\n  expiresAt: Date;\n  issuedAt: Date;\n  fingerprint?: string;\n}\n\ninterface CookieOptions {\n  httpOnly: boolean;\n  secure: boolean;\n  sameSite: 'strict' | 'lax' | 'none';\n  path: string;\n  expires?: Date;\n  maxAge?: number;\n}\n\ninterface TokenSecurityAnalysis {\n  algorithm: string;\n  hasFingerprint: boolean;\n  expirationTime: Date;\n  issuedAt: Date;\n  timeUntilExpiry: number;\n  strength: 'weak' | 'medium' | 'strong';\n}\n\ninterface AutoRotationOptions {\n  checkInterval?: number;\n  rotateBeforeExpiry?: number;\n}"],"names":["Tokenly","constructor","config","this","currentToken","blacklistedTokens","Set","deviceTokens","Map","rotationCounts","revokedTokens","autoRotationInterval","secretAccess","process","env","JWT_SECRET_ACCESS","secretRefresh","JWT_SECRET_REFRESH","accessTokenExpiry","ACCESS_TOKEN_EXPIRY","refreshTokenExpiry","REFRESH_TOKEN_EXPIRY","cookieOptions","httpOnly","secure","NODE_ENV","sameSite","path","maxAge","jwtOptions","algorithm","issuer","audience","verifyOptions","algorithms","clockTolerance","rotationConfig","enableAutoRotation","rotationInterval","maxRotationCount","securityConfig","enableFingerprint","enableBlacklist","maxDevices","revokeOnSecurityBreach","eventListeners","tokenCache","formatDate","timestamp","Date","toISOString","decodeWithReadableDates","token","decoded","jwt","decode","iat","exp","payloadWithoutDates","raw","payload","undefined","generateFingerprint","context","userAgent","ip","Error","cleanUserAgent","replace","cleanIP","baseFingerprint","ua","uaLength","length","ipLength","ipSegments","split","join","now","additional","additionalData","fingerprintStr","JSON","stringify","hash","crypto","createHash","update","digest","console","log","revokeToken","add","emit","userId","error","isTokenBlacklisted","has","validatePayload","Object","keys","prototype","hasOwnProperty","call","trim","entries","forEach","key","value","generateAccessToken","options","finalPayload","fingerprint","set","userDevices","get","size","sign","expiresIn","response","verifyAccessToken","verified","verify","ignoreExpiration","storedFingerprint","currentFingerprint","stored","current","storedContext","fingerprintContext","currentContext","generateRefreshToken","aud","iss","cookieConfig","name","verifyRefreshToken","rotateTokens","refreshToken","tokenId","currentCount","accessToken","setToken","getToken","clearToken","isTokenExpiringSoon","thresholdMinutes","expirationTime","currentTime","getTokenInfo","expiresAt","issuedAt","validateTokenFormat","parts","every","part","Buffer","from","toString","generateOneTimeToken","purpose","nonce","randomBytes","Math","floor","getEnhancedCookieOptions","expires","verifyRefreshTokenEnhanced","on","event","callback","push","data","listeners","cacheToken","setTimeout","delete","analyzeTokenSecurity","complete","header","alg","hasFingerprint","timeUntilExpiry","strength","calculateTokenStrength","decodedToken","score","checkInterval","rotateBeforeExpiry","clearInterval","checkTokensExpiration","setInterval","disableAutoRotation","Array","_","enableAutoCleanup","interval","findTokenByFingerprint","devices","validateDeviceLimit","currentDevices"],"mappings":"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"}