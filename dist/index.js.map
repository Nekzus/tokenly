{"version":3,"file":"index.js","sources":["../src/tokenManager.ts"],"sourcesContent":["import crypto from 'crypto';\nimport jwt from 'jsonwebtoken';\n\ninterface TokenlyOptions {\n  secure?: boolean;\n  httpOnly?: boolean;\n  sameSite?: 'strict' | 'lax' | 'none';\n  domain?: string;\n  path?: string;\n  maxAge?: number;\n}\n\ninterface TokenlyConfig {\n  accessTokenExpiry?: string;\n  refreshTokenExpiry?: string;\n  cookieOptions?: TokenlyOptions;\n  jwtOptions?: {\n    algorithm?: jwt.Algorithm;\n    audience?: string | string[];\n    issuer?: string;\n    jwtid?: string;\n    subject?: string;\n    notBefore?: string | number;\n    maxAge?: string | number;\n  };\n  rotationConfig?: {\n    enableAutoRotation?: boolean;\n    rotationInterval?: number;\n    maxRotationCount?: number;\n  };\n  securityConfig?: {\n    enableFingerprint?: boolean;\n    enableBlacklist?: boolean;\n    maxDevices?: number;\n    revokeOnSecurityBreach?: boolean;\n  };\n}\n\ninterface TokenlyToken {\n  iat: number;\n  exp: number;\n  [key: string]: any;\n}\n\ninterface TokenlyResponse {\n  raw: string;\n  payload: {\n    [key: string]: any;\n    iat?: Date;\n    exp?: Date;\n  };\n  cookieConfig?: {\n    name: string;\n    value: string;\n    options: TokenlyOptions;\n  };\n}\n\n/**\n * Tokenly - A secure JWT token manager with HttpOnly cookie support\n * Implements best security practices for JWT token handling in modern web applications\n */\nexport class Tokenly {\n  private secretAccess: string;\n  private secretRefresh: string;\n  private accessTokenExpiry: string;\n  private refreshTokenExpiry: string;\n  private cookieOptions: TokenlyOptions;\n  private jwtOptions: jwt.SignOptions;\n  private verifyOptions: jwt.VerifyOptions;\n  private currentToken: string | null = null;\n  private blacklistedTokens: Set<string> = new Set();\n  private rotationConfig: Required<NonNullable<TokenlyConfig['rotationConfig']>>;\n  private securityConfig: Required<NonNullable<TokenlyConfig['securityConfig']>>;\n  private deviceTokens: Map<string, Set<string>> = new Map();\n  private rotationCounts: Map<string, number> = new Map();\n  private revokedTokens: Set<string> = new Set();\n  private tokenCache: Map<string, TokenlyResponse>;\n  private eventListeners: Map<string, Function[]>;\n  private autoRotationInterval: NodeJS.Timeout | null = null;\n\n  /**\n   * Initialize Tokenly with custom configuration\n   * @param config Optional configuration for token management\n   */\n  constructor(config?: TokenlyConfig) {\n    this.secretAccess = process.env.JWT_SECRET_ACCESS || 'default-secret-access';\n    this.secretRefresh = process.env.JWT_SECRET_REFRESH || 'default-secret-refresh';\n    this.accessTokenExpiry = config?.accessTokenExpiry || process.env.ACCESS_TOKEN_EXPIRY || '15m';\n    this.refreshTokenExpiry = config?.refreshTokenExpiry || process.env.REFRESH_TOKEN_EXPIRY || '7d';\n\n    // Default secure cookie configuration\n    this.cookieOptions = {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'strict',\n      path: '/',\n      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 días\n      ...config?.cookieOptions,\n    };\n\n    // Default secure JWT configuration\n    this.jwtOptions = {\n      algorithm: 'HS512',\n      issuer: 'tokenly-auth',\n      audience: 'tokenly-client',\n      ...config?.jwtOptions,\n    };\n\n    // Configuración JWT para verificación\n    this.verifyOptions = {\n      algorithms: [this.jwtOptions.algorithm as jwt.Algorithm],\n      issuer: this.jwtOptions.issuer,\n      audience: this.jwtOptions.audience,\n      clockTolerance: 30, // 30 segundos de tolerancia solo para verificación\n    };\n\n    // Configuración de rotación automática\n    this.rotationConfig = {\n      enableAutoRotation: true,\n      rotationInterval: 60, // 60 minutos\n      maxRotationCount: 100,\n      ...config?.rotationConfig,\n    };\n\n    // Configuración de seguridad\n    this.securityConfig = {\n      enableFingerprint: true,\n      enableBlacklist: true,\n      maxDevices: 5,\n      revokeOnSecurityBreach: true,\n      ...config?.securityConfig,\n    };\n\n    this.eventListeners = new Map();\n    this.tokenCache = new Map();\n  }\n\n  /**\n   * Format Unix timestamp to ISO date string\n   * @param timestamp Unix timestamp in seconds\n   * @returns ISO 8601 formatted date string\n   */\n  private formatDate(timestamp: number): string {\n    return new Date(timestamp * 1000).toISOString();\n  }\n\n  /**\n   * Decode token and add readable dates\n   * @param token JWT token string\n   * @param decoded Decoded token payload\n   * @param cookieConfig Optional cookie configuration\n   * @returns Formatted token response\n   */\n  private decodeWithReadableDates(\n    token: string,\n    decoded?: any\n  ): TokenlyResponse {\n    if (!decoded) {\n      decoded = jwt.decode(token) as TokenlyToken;\n    }\n\n    const { iat, exp, ...payloadWithoutDates } = decoded;\n    \n    const result: TokenlyResponse = {\n      raw: token,\n      payload: {\n        ...payloadWithoutDates,\n        iat: iat ? new Date(iat * 1000) : undefined,\n        exp: exp ? new Date(exp * 1000) : undefined,\n      }\n    };\n\n    return result;\n  }\n\n  /**\n   * Genera una huella digital del dispositivo/navegador\n   */\n  private generateFingerprint(context: { userAgent: string; ip: string; additionalData?: string }): string {\n    if (!context.userAgent || !context.ip) {\n      throw new Error('Invalid context for fingerprint generation');\n    }\n    return crypto\n      .createHash('sha256')\n      .update(`${context.userAgent}${context.ip}${context.additionalData || ''}`)\n      .digest('hex');\n  }\n\n  /**\n   * Revoca un token específico\n   */\n  public revokeToken(token: string): void {\n    if (!token) return;\n    \n    try {\n      const decoded = jwt.decode(token) as jwt.JwtPayload;\n      this.revokedTokens.add(token);\n      \n      this.emit('tokenRevoked', {\n        token,\n        userId: decoded?.userId,\n        timestamp: Date.now()\n      });\n    } catch (error) {\n      console.error('Error al revocar token:', error);\n    }\n  }\n\n  /**\n   * Verifica si un token está en la lista negra\n   */\n  private isTokenBlacklisted(token: string): boolean {\n    return this.securityConfig.enableBlacklist && this.blacklistedTokens.has(token);\n  }\n\n  private validatePayload(payload: any): void {\n    // Validar que payload sea un objeto\n    if (payload === null || typeof payload !== 'object') {\n      throw new Error('Payload must be an object');\n    }\n    \n    // Validar que no esté vacío\n    if (Object.keys(payload).length === 0) {\n      throw new Error('Payload cannot be empty');\n    }\n\n    // Validar que tenga userId\n    if (!Object.prototype.hasOwnProperty.call(payload, 'userId')) {\n      throw new Error('Payload must contain a userId');\n    }\n    \n    // Validar que userId no sea null o undefined\n    if (payload.userId === null || payload.userId === undefined) {\n      throw new Error('userId cannot be null or undefined');\n    }\n\n    // Validar que userId no esté vacío\n    if (typeof payload.userId !== 'string' || !payload.userId.trim()) {\n      throw new Error('userId cannot be empty');\n    }\n\n    // Validar que ninguna propiedad sea null o undefined\n    Object.entries(payload).forEach(([key, value]) => {\n      if (value === null || value === undefined) {\n        throw new Error(`Payload property '${key}' cannot be null or undefined`);\n      }\n    });\n\n    // Validar tamaño del payload\n    const payloadSize = JSON.stringify(payload).length;\n    if (payloadSize > 8192) {\n      throw new Error('Payload size exceeds maximum allowed size');\n    }\n  }\n\n  /**\n   * Generate a new access token\n   * @param payload Token payload\n   * @param options Optional JWT sign options\n   * @returns Token response with readable dates\n   */\n  generateAccessToken(\n    payload: object,\n    options?: jwt.SignOptions,\n    context?: { userAgent: string; ip: string; additionalData?: string }\n  ): TokenlyResponse {\n    this.validatePayload(payload);\n    const finalPayload: { [key: string]: any } = { ...payload };\n\n    if (this.securityConfig.enableFingerprint && context) {\n      const fingerprint = this.generateFingerprint(context);\n      const userId = (payload as any).userId;\n      \n      if (!this.deviceTokens.has(userId)) {\n        this.deviceTokens.set(userId, new Set());\n      }\n      \n      const userDevices = this.deviceTokens.get(userId)!;\n      if (userDevices.size >= this.securityConfig.maxDevices && !userDevices.has(fingerprint)) {\n        throw new Error('Maximum number of devices reached');\n      }\n      \n      userDevices.add(fingerprint);\n      finalPayload.fingerprint = fingerprint;\n    }\n\n    const token = jwt.sign(finalPayload, this.secretAccess, {\n      ...this.jwtOptions,\n      ...options,\n      expiresIn: this.accessTokenExpiry,\n    });\n\n    const response = this.decodeWithReadableDates(token);\n    this.tokenCache.set(token, response);\n    return response;\n  }\n\n  /**\n   * Verify an access token\n   * @param token JWT token string\n   * @returns Verified token response\n   */\n  public verifyAccessToken(\n    token: string,\n    context?: { userAgent: string; ip: string; additionalData?: string }\n  ): TokenlyResponse {\n    if (this.revokedTokens.has(token)) {\n      throw new Error('Token has been revoked');\n    }\n\n    const verified = jwt.verify(token, this.secretAccess, {\n      ...this.verifyOptions,\n      ignoreExpiration: false,\n      clockTolerance: 0\n    }) as TokenlyToken;\n\n    if (this.securityConfig.enableFingerprint && context) {\n      const currentFingerprint = this.generateFingerprint(context);\n      if (verified.fingerprint && verified.fingerprint !== currentFingerprint) {\n        throw new Error('Invalid token fingerprint');\n      }\n    }\n\n    const response = this.decodeWithReadableDates(token, verified);\n    this.tokenCache.set(token, response);\n    return response;\n  }\n\n  /**\n   * Generate a new refresh token with HttpOnly cookie configuration\n   * @param payload Token payload\n   * @param cookieOptions Optional cookie configuration\n   * @returns Token response with cookie configuration\n   */\n  generateRefreshToken(\n    payload: object,\n    cookieOptions?: TokenlyOptions\n  ): TokenlyResponse {\n    this.validatePayload(payload);\n    const finalPayload: { [key: string]: any } = { ...payload };\n    \n    // Eliminar propiedades JWT existentes\n    delete (finalPayload as any).aud;\n    delete (finalPayload as any).iss;\n    delete (finalPayload as any).exp;\n    delete (finalPayload as any).iat;\n\n    const token = jwt.sign(finalPayload, this.secretRefresh, {\n      ...this.jwtOptions,\n      expiresIn: this.refreshTokenExpiry,\n    });\n\n    const response = this.decodeWithReadableDates(token);\n    response.cookieConfig = {\n      name: 'refresh_token',\n      value: token,\n      options: {\n        ...this.cookieOptions,\n        ...cookieOptions,\n      }\n    };\n\n    return response;\n  }\n\n  /**\n   * Verify a refresh token\n   * @param token JWT token string\n   * @returns Verified token response\n   */\n  verifyRefreshToken(token: string): TokenlyResponse {\n    const decoded = jwt.verify(token, this.secretRefresh, this.verifyOptions) as TokenlyToken;\n    return this.decodeWithReadableDates(token, decoded);\n  }\n\n  /**\n   * Rotate access and refresh tokens\n   * @param refreshToken Current refresh token\n   * @param newPayload Optional new payload for the tokens\n   * @returns New access and refresh tokens\n   */\n  rotateTokens(refreshToken: string): {\n    accessToken: TokenlyResponse;\n    refreshToken: TokenlyResponse;\n  } {\n    if (!refreshToken || typeof refreshToken !== 'string') {\n      throw new Error('Invalid refresh token format');\n    }\n\n    const verified = this.verifyRefreshToken(refreshToken);\n    const { iat, exp, aud, iss, ...payload } = verified.payload;\n\n    // Verificar límite de rotaciones\n    const tokenId = refreshToken;\n    const currentCount = this.rotationCounts.get(tokenId) || 0;\n    \n    if (currentCount >= (this.rotationConfig.maxRotationCount || 2)) {\n      throw new Error('Maximum rotation count exceeded');\n    }\n    \n    this.rotationCounts.set(tokenId, currentCount + 1);\n\n    return {\n      accessToken: this.generateAccessToken(payload),\n      refreshToken: this.generateRefreshToken(payload)\n    };\n  }\n\n  /**\n   * Store a token\n   * @param token Token string to store\n   */\n  setToken(token: string): void {\n    this.currentToken = token;\n  }\n\n  /**\n   * Retrieve the stored token\n   * @returns The stored token or null if none exists\n   */\n  getToken(): string | null {\n    return this.currentToken;\n  }\n\n  /**\n   * Clear the stored token\n   */\n  clearToken(): void {\n    this.currentToken = null;\n  }\n\n  /**\n   * Helper para verificar si un token está próximo a expirar\n   * @param token Token a verificar\n   * @param thresholdMinutes Minutos antes de la expiración para considerar como \"próximo a expirar\"\n   */\n  public isTokenExpiringSoon(token: string, thresholdMinutes: number = 5): boolean {\n    try {\n      const decoded = jwt.decode(token) as jwt.JwtPayload;\n      if (!decoded || !decoded.exp) return false;\n\n      const expirationTime = decoded.exp * 1000;\n      const currentTime = Date.now();\n      const timeUntilExpiry = expirationTime - currentTime;\n      \n      return timeUntilExpiry < (thresholdMinutes * 60 * 1000);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Helper para obtener información del token de forma segura\n   * @param token Token a decodificar\n   */\n  public getTokenInfo(token: string): TokenInfo | null {\n    try {\n      const decoded = jwt.decode(token) as jwt.JwtPayload;\n      if (!decoded) return null;\n\n      return {\n        userId: decoded.userId as string,\n        expiresAt: new Date(decoded.exp! * 1000),\n        issuedAt: new Date(decoded.iat! * 1000),\n        fingerprint: decoded.fingerprint as string | undefined\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Validar un token sin verificar la firma (útil para pre-validaciones)\n   * @param token Token a validar\n   */\n  public validateTokenFormat(token: string): boolean {\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) return false;\n\n      return parts.every(part => {\n        try {\n          Buffer.from(part, 'base64').toString();\n          return true;\n        } catch {\n          return false;\n        }\n      });\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Generar un token temporal de un solo uso\n   * @param purpose Propósito del token\n   * @param expiresIn Tiempo de expiración\n   */\n  public generateOneTimeToken(purpose: string, expiresIn: string = '5m'): string {\n    const payload = {\n      purpose,\n      nonce: crypto.randomBytes(16).toString('hex'),\n      iat: Math.floor(Date.now() / 1000)\n    };\n\n    return jwt.sign(payload, this.secretAccess, { expiresIn });\n  }\n\n  /**\n   * Mejorar la seguridad de las cookies con flags adicionales\n   */\n  private getEnhancedCookieOptions(): CookieOptions {\n    return {\n      ...this.cookieOptions,\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'strict' as const,\n      path: '/',\n      expires: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),\n      maxAge: 7 * 24 * 60 * 60 * 1000\n    };\n  }\n\n  /**\n   * Validar un refresh token con verificaciones adicionales de seguridad\n   */\n  public verifyRefreshTokenEnhanced(token: string): TokenlyResponse {\n    if (!this.validateTokenFormat(token)) {\n      throw new Error('Invalid token format');\n    }\n\n    const verified = this.verifyRefreshToken(token);\n    \n    if (this.isTokenExpiringSoon(token, 60)) {\n      throw new Error('Refresh token is about to expire');\n    }\n\n    return verified;\n  }\n\n  // Sistema de eventos\n  public on(event: string, callback: Function): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event)?.push(callback);\n  }\n\n  private emit(event: string, data: any): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners?.length) {\n      listeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          // Silent error handling for callbacks\n        }\n      });\n    }\n  }\n\n  // Sistema de caché con auto-limpieza\n  private cacheToken(key: string, value: TokenlyResponse): void {\n    this.tokenCache.set(key, value);\n    \n    // Auto-limpieza después de 5 minutos\n    setTimeout(() => {\n      this.tokenCache.delete(key);\n    }, 5 * 60 * 1000);\n  }\n\n  // Análisis de seguridad del token\n  public analyzeTokenSecurity(token: string): TokenSecurityAnalysis {\n    const decoded = jwt.decode(token, { complete: true }) as { \n      header: { alg: string }, \n      payload: TokenlyToken & { fingerprint?: string } \n    };\n    if (!decoded) throw new Error('Invalid token');\n\n    return {\n      algorithm: decoded.header.alg,\n      hasFingerprint: !!decoded.payload.fingerprint,\n      expirationTime: new Date(decoded.payload.exp * 1000),\n      issuedAt: new Date(decoded.payload.iat * 1000),\n      timeUntilExpiry: (decoded.payload.exp * 1000) - Date.now(),\n      strength: this.calculateTokenStrength(decoded)\n    };\n  }\n\n  // Calcular la fortaleza del token\n  private calculateTokenStrength(decodedToken: any): 'weak' | 'medium' | 'strong' {\n    let score = 0;\n    \n    // Verificar algoritmo\n    if (decodedToken.header.alg === 'HS512') score += 2;\n    else if (decodedToken.header.alg === 'HS256') score += 1;\n    \n    // Verificar fingerprint\n    if (decodedToken.payload.fingerprint) score += 2;\n    \n    // Verificar tiempo de expiración\n    const timeUntilExpiry = (decodedToken.payload.exp * 1000) - Date.now();\n    if (timeUntilExpiry < 15 * 60 * 1000) score += 1; // < 15 minutos\n    else if (timeUntilExpiry < 60 * 60 * 1000) score += 2; // < 1 hora\n    \n    return score <= 2 ? 'weak' : score <= 4 ? 'medium' : 'strong';\n  }\n\n  // Rotación automática de tokens\n  public enableAutoRotation(options: AutoRotationOptions = {}): NodeJS.Timeout {\n    console.log('Enabling auto rotation...');\n    const {\n      checkInterval = 50,\n      rotateBeforeExpiry = 1000\n    } = options;\n\n    if (this.autoRotationInterval) {\n      clearInterval(this.autoRotationInterval);\n    }\n\n    // Ejecutar verificación inmediata\n    this.checkTokensExpiration(rotateBeforeExpiry);\n\n    // Configurar nuevo intervalo\n    this.autoRotationInterval = setInterval(() => {\n      this.checkTokensExpiration(rotateBeforeExpiry);\n    }, checkInterval);\n\n    return this.autoRotationInterval;\n  }\n\n  // Método para detener la auto-rotación\n  public disableAutoRotation(): void {\n    if (this.autoRotationInterval) {\n      clearInterval(this.autoRotationInterval);\n      this.autoRotationInterval = null;\n    }\n  }\n\n  private checkTokensExpiration(rotateBeforeExpiry: number): void {\n    Array.from(this.tokenCache.entries()).forEach(([token, _]) => {\n      try {\n        const decoded = jwt.decode(token) as jwt.JwtPayload;\n        if (decoded?.exp) {\n          const timeUntilExpiry = (decoded.exp * 1000) - Date.now();\n          if (timeUntilExpiry < rotateBeforeExpiry) {\n            this.emit('tokenExpiring', {\n              token,\n              userId: decoded.userId,\n              expiresIn: timeUntilExpiry\n            });\n          }\n        }\n      } catch (error) {\n        // Silent error handling for token checks\n      }\n    });\n  }\n\n  // Limpieza automática de tokens revocados\n  public enableAutoCleanup(interval: number = 3600000): void { // 1 hora por defecto\n    setInterval(() => {\n      const now = Date.now();\n      this.revokedTokens.forEach(token => {\n        try {\n          const decoded = jwt.decode(token) as jwt.JwtPayload;\n          if (decoded && decoded.exp && decoded.exp * 1000 < now) {\n            this.revokedTokens.delete(token);\n          }\n        } catch {\n          // Token inválido, eliminarlo\n          this.revokedTokens.delete(token);\n        }\n      });\n    }, interval);\n  }\n\n  private findTokenByFingerprint(fingerprint: string): string | null {\n    for (const [, devices] of this.deviceTokens.entries()) {\n      if (devices.has(fingerprint)) {\n        return this.getToken();\n      }\n    }\n    return null;\n  }\n\n  private async validateDeviceLimit(userId: string, fingerprint: string): Promise<void> {\n    if (!this.deviceTokens.has(userId)) {\n      this.deviceTokens.set(userId, new Set());\n    }\n\n    const userDevices = this.deviceTokens.get(userId)!;\n    \n    if (userDevices.size >= this.securityConfig.maxDevices && !userDevices.has(fingerprint)) {\n      this.emit('maxDevicesReached', {\n        userId,\n        currentDevices: Array.from(userDevices),\n        maxDevices: this.securityConfig.maxDevices\n      });\n      throw new Error('Maximum number of devices reached');\n    }\n    \n    userDevices.add(fingerprint);\n  }\n}\n\n// Tipos adicionales\ninterface TokenInfo {\n  userId: string;\n  expiresAt: Date;\n  issuedAt: Date;\n  fingerprint?: string;\n}\n\ninterface CookieOptions {\n  httpOnly: boolean;\n  secure: boolean;\n  sameSite: 'strict' | 'lax' | 'none';\n  path: string;\n  expires?: Date;\n  maxAge?: number;\n}\n\ninterface TokenSecurityAnalysis {\n  algorithm: string;\n  hasFingerprint: boolean;\n  expirationTime: Date;\n  issuedAt: Date;\n  timeUntilExpiry: number;\n  strength: 'weak' | 'medium' | 'strong';\n}\n\ninterface AutoRotationOptions {\n  checkInterval?: number;\n  rotateBeforeExpiry?: number;\n}"],"names":["Tokenly","constructor","config","this","currentToken","blacklistedTokens","Set","deviceTokens","Map","rotationCounts","revokedTokens","autoRotationInterval","secretAccess","process","env","JWT_SECRET_ACCESS","secretRefresh","JWT_SECRET_REFRESH","accessTokenExpiry","ACCESS_TOKEN_EXPIRY","refreshTokenExpiry","REFRESH_TOKEN_EXPIRY","cookieOptions","httpOnly","secure","NODE_ENV","sameSite","path","maxAge","jwtOptions","algorithm","issuer","audience","verifyOptions","algorithms","clockTolerance","rotationConfig","enableAutoRotation","rotationInterval","maxRotationCount","securityConfig","enableFingerprint","enableBlacklist","maxDevices","revokeOnSecurityBreach","eventListeners","tokenCache","formatDate","timestamp","Date","toISOString","decodeWithReadableDates","token","decoded","jwt","decode","iat","exp","payloadWithoutDates","raw","payload","undefined","generateFingerprint","context","userAgent","ip","Error","crypto","createHash","update","additionalData","digest","revokeToken","add","emit","userId","now","error","console","isTokenBlacklisted","has","validatePayload","Object","keys","length","prototype","hasOwnProperty","call","trim","entries","forEach","key","value","JSON","stringify","generateAccessToken","options","finalPayload","fingerprint","set","userDevices","get","size","sign","expiresIn","response","verifyAccessToken","verified","verify","ignoreExpiration","currentFingerprint","generateRefreshToken","aud","iss","cookieConfig","name","verifyRefreshToken","rotateTokens","refreshToken","tokenId","currentCount","accessToken","setToken","getToken","clearToken","isTokenExpiringSoon","thresholdMinutes","expirationTime","currentTime","getTokenInfo","expiresAt","issuedAt","validateTokenFormat","parts","split","every","part","Buffer","from","toString","generateOneTimeToken","purpose","nonce","randomBytes","Math","floor","getEnhancedCookieOptions","expires","verifyRefreshTokenEnhanced","on","event","callback","push","data","listeners","cacheToken","setTimeout","delete","analyzeTokenSecurity","complete","header","alg","hasFingerprint","timeUntilExpiry","strength","calculateTokenStrength","decodedToken","score","log","checkInterval","rotateBeforeExpiry","clearInterval","checkTokensExpiration","setInterval","disableAutoRotation","Array","_","enableAutoCleanup","interval","findTokenByFingerprint","devices","validateDeviceLimit","currentDevices"],"mappings":"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"}