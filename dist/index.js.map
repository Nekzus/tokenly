{"version":3,"file":"index.js","sources":["../src/tokenManager.ts","../src/utils/ipHelper.ts"],"sourcesContent":["import crypto from 'crypto';\nimport jwt from 'jsonwebtoken';\n\ninterface TokenlyOptions {\n  secure?: boolean;\n  httpOnly?: boolean;\n  sameSite?: 'strict' | 'lax' | 'none';\n  domain?: string;\n  path?: string;\n  maxAge?: number;\n}\n\ninterface TokenlyConfig {\n  accessTokenExpiry?: string;\n  refreshTokenExpiry?: string;\n  cookieOptions?: TokenlyOptions;\n  jwtOptions?: {\n    algorithm?: jwt.Algorithm;\n    audience?: string | string[];\n    issuer?: string;\n    jwtid?: string;\n    subject?: string;\n    notBefore?: string | number;\n    maxAge?: string | number;\n  };\n  rotationConfig?: {\n    enableAutoRotation?: boolean;\n    rotationInterval?: number;\n    maxRotationCount?: number;\n  };\n  securityConfig?: {\n    enableFingerprint?: boolean;\n    enableBlacklist?: boolean;\n    maxDevices?: number;\n    revokeOnSecurityBreach?: boolean;\n  };\n}\n\ninterface TokenlyToken {\n  iat: number;\n  exp: number;\n  [key: string]: any;\n}\n\ninterface TokenlyResponse {\n  raw: string;\n  payload: {\n    [key: string]: any;\n    iat?: Date;\n    exp?: Date;\n  };\n  cookieConfig?: {\n    name: string;\n    value: string;\n    options: TokenlyOptions;\n  };\n}\n\n/**\n * Tokenly - A secure JWT token manager with HttpOnly cookie support\n * Implements best security practices for JWT token handling in modern web applications\n */\nexport class Tokenly {\n  private secretAccess: string;\n  private secretRefresh: string;\n  private accessTokenExpiry: string;\n  private refreshTokenExpiry: string;\n  private cookieOptions: TokenlyOptions;\n  private jwtOptions: jwt.SignOptions;\n  private verifyOptions: jwt.VerifyOptions;\n  private currentToken: string | null = null;\n  private blacklistedTokens: Set<string> = new Set();\n  private rotationConfig: Required<NonNullable<TokenlyConfig['rotationConfig']>>;\n  private securityConfig: Required<NonNullable<TokenlyConfig['securityConfig']>>;\n  private deviceTokens: Map<string, Set<string>> = new Map();\n  private rotationCounts: Map<string, number> = new Map();\n  private revokedTokens: Set<string> = new Set();\n  private tokenCache: Map<string, TokenlyResponse>;\n  private eventListeners: Map<string, Function[]>;\n  private autoRotationInterval: NodeJS.Timeout | null = null;\n  private fingerprintCache: Map<string, string> = new Map();\n  private readonly instanceId: string;\n\n  /**\n   * Initialize Tokenly with custom configuration\n   * @param config Optional configuration for token management\n   */\n  constructor(config?: TokenlyConfig) {\n    // Generar ID único para esta instancia\n    this.instanceId = crypto.randomBytes(16).toString('hex');\n\n    // Generar secrets aleatorios si no se proporcionan\n    this.secretAccess = process.env.JWT_SECRET_ACCESS || this.generateSecret('access');\n    this.secretRefresh = process.env.JWT_SECRET_REFRESH || this.generateSecret('refresh');\n\n    // Advertir si se están usando secrets auto-generados\n    if (!process.env.JWT_SECRET_ACCESS || !process.env.JWT_SECRET_REFRESH) {\n      console.warn(\n        '\\x1b[33m%s\\x1b[0m',\n        `WARNING: Using auto-generated secrets. This is secure but tokens will be invalidated on server restart. \n        For production, please set JWT_SECRET_ACCESS and JWT_SECRET_REFRESH environment variables.\n        Instance ID: ${this.instanceId}`\n      );\n    }\n\n    this.accessTokenExpiry = config?.accessTokenExpiry || process.env.ACCESS_TOKEN_EXPIRY || '15m';\n    this.refreshTokenExpiry = config?.refreshTokenExpiry || process.env.REFRESH_TOKEN_EXPIRY || '7d';\n\n    // Default secure cookie configuration\n    this.cookieOptions = {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'strict',\n      path: '/',\n      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 días\n      ...config?.cookieOptions,\n    };\n\n    // Default secure JWT configuration\n    this.jwtOptions = {\n      algorithm: 'HS512',\n      issuer: 'tokenly-auth',\n      audience: 'tokenly-client',\n      ...config?.jwtOptions,\n    };\n\n    // Configuración JWT para verificación\n    this.verifyOptions = {\n      algorithms: [this.jwtOptions.algorithm as jwt.Algorithm],\n      issuer: this.jwtOptions.issuer,\n      audience: this.jwtOptions.audience,\n      clockTolerance: 30, // 30 segundos de tolerancia solo para verificación\n    };\n\n    // Configuración de rotación automática\n    this.rotationConfig = {\n      enableAutoRotation: true,\n      rotationInterval: 60, // 60 minutos\n      maxRotationCount: 100,\n      ...config?.rotationConfig,\n    };\n\n    // Configuración de seguridad\n    this.securityConfig = {\n      enableFingerprint: true,\n      enableBlacklist: true,\n      maxDevices: 5,\n      revokeOnSecurityBreach: true,\n      ...config?.securityConfig,\n    };\n\n    this.eventListeners = new Map();\n    this.tokenCache = new Map();\n  }\n\n  private generateSecret(type: 'access' | 'refresh'): string {\n    return crypto\n      .createHash('sha256')\n      .update(`${this.instanceId}-${type}-${Date.now()}`)\n      .digest('hex');\n  }\n\n  /**\n   * Format Unix timestamp to ISO date string\n   * @param timestamp Unix timestamp in seconds\n   * @returns ISO 8601 formatted date string\n   */\n  private formatDate(timestamp: number): string {\n    return new Date(timestamp * 1000).toISOString();\n  }\n\n  /**\n   * Decode token and add readable dates\n   * @param token JWT token string\n   * @param decoded Decoded token payload\n   * @param cookieConfig Optional cookie configuration\n   * @returns Formatted token response\n   */\n  private decodeWithReadableDates(\n    token: string,\n    decoded?: any\n  ): TokenlyResponse {\n    if (!decoded) {\n      decoded = jwt.decode(token) as TokenlyToken;\n    }\n\n    const { iat, exp, ...payloadWithoutDates } = decoded;\n    \n    const result: TokenlyResponse = {\n      raw: token,\n      payload: {\n        ...payloadWithoutDates,\n        iat: iat ? this.formatDate(iat) : undefined,\n        exp: exp ? this.formatDate(exp) : undefined,\n      }\n    };\n\n    return result;\n  }\n\n  /**\n   * Genera una huella digital del dispositivo/navegador\n   */\n  private generateFingerprint(context: { userAgent: string; ip: string }): string {\n    if (!context?.userAgent?.trim() || !context?.ip?.trim()) {\n        throw new Error('Invalid or empty context values');\n    }\n\n    // Normalización\n    const normalizedUA = context.userAgent\n        .trim()\n        .toLowerCase()\n        .replace(/\\s+/g, ' ');\n    \n    const normalizedIP = context.ip\n        .trim()\n        .toLowerCase()\n        .replace(/[^0-9.]/g, '');\n\n    // Crear hashes individuales con entropy adicional\n    const uaHash = crypto\n        .createHash('sha256')\n        .update(`ua:${this.instanceId}:${normalizedUA}`)\n        .digest('hex');\n    \n    const ipHash = crypto\n        .createHash('sha256')\n        .update(`ip:${this.instanceId}:${normalizedIP}`)\n        .digest('hex');\n\n    // Combinar hashes con prefijos para garantizar unicidad\n    const combinedData = `ua=${uaHash}|ip=${ipHash}`;\n\n    // Hash final\n    return crypto\n        .createHash('sha256')\n        .update(combinedData)\n        .digest('hex');\n  }\n\n  /**\n   * Revoca un token específico\n   */\n  public revokeToken(token: string): void {\n    if (!token) return;\n    \n    try {\n      const decoded = jwt.decode(token) as jwt.JwtPayload;\n      this.revokedTokens.add(token);\n      \n      this.emit('tokenRevoked', {\n        token,\n        userId: decoded?.userId,\n        timestamp: Date.now()\n      });\n    } catch (error) {\n      console.error('Error al revocar token:', error);\n    }\n  }\n\n  /**\n   * Verifica si un token está en la lista negra\n   */\n  private isTokenBlacklisted(token: string): boolean {\n    return this.securityConfig.enableBlacklist && this.blacklistedTokens.has(token);\n  }\n\n  private validatePayload(payload: any): void {\n    // Validar que payload sea un objeto\n    if (payload === null || typeof payload !== 'object') {\n      throw new Error('Payload must be an object');\n    }\n    \n    // Validar que no esté vacío\n    if (Object.keys(payload).length === 0) {\n      throw new Error('Payload cannot be empty');\n    }\n\n    // Validar que tenga userId\n    if (!Object.prototype.hasOwnProperty.call(payload, 'userId')) {\n      throw new Error('Payload must contain a userId');\n    }\n    \n    // Validar que userId no sea null o undefined\n    if (payload.userId === null || payload.userId === undefined) {\n      throw new Error('userId cannot be null or undefined');\n    }\n\n    // Validar que userId no esté vacío\n    if (typeof payload.userId !== 'string' || !payload.userId.trim()) {\n      throw new Error('userId cannot be empty');\n    }\n\n    // Validar que ninguna propiedad sea null o undefined\n    Object.entries(payload).forEach(([key, value]) => {\n      if (value === null || value === undefined) {\n        throw new Error(`Payload property '${key}' cannot be null or undefined`);\n      }\n    });\n\n    // Validar tamaño del payload\n    const payloadSize = JSON.stringify(payload).length;\n    if (payloadSize > 8192) {\n      throw new Error('Payload size exceeds maximum allowed size');\n    }\n  }\n\n  /**\n   * Generate a new access token\n   * @param payload Token payload\n   * @param options Optional JWT sign options\n   * @returns Token response with readable dates\n   */\n  generateAccessToken(\n    payload: object,\n    options?: jwt.SignOptions,\n    context?: { userAgent: string; ip: string }\n  ): TokenlyResponse {\n    this.validatePayload(payload);\n    const finalPayload: { [key: string]: any } = { ...payload };\n\n    if (this.securityConfig.enableFingerprint && context) {\n      const fingerprint = this.generateFingerprint(context);\n      const userId = (payload as any).userId;\n      this.handleDeviceStorage(userId, fingerprint);\n      finalPayload.fingerprint = fingerprint;\n    }\n\n    const token = jwt.sign(finalPayload, this.secretAccess, {\n      ...this.jwtOptions,\n      ...options,\n      expiresIn: this.accessTokenExpiry,\n    });\n\n    const response = this.decodeWithReadableDates(token);\n    this.cacheToken(token, response);\n    return response;\n  }\n\n  /**\n   * Verify an access token\n   * @param token JWT token string\n   * @returns Verified token response\n   */\n  public verifyAccessToken(\n    token: string,\n    context?: { userAgent: string; ip: string; additionalData?: string }\n  ): TokenlyResponse {\n    if (this.revokedTokens.has(token) || this.isTokenBlacklisted(token)) {\n      throw new Error('Token has been revoked');\n    }\n\n    const verified = jwt.verify(token, this.secretAccess, {\n      ...this.verifyOptions,\n      ignoreExpiration: false,\n      clockTolerance: 0\n    }) as TokenlyToken;\n\n    if (this.securityConfig.enableFingerprint && context) {\n      const currentFingerprint = this.generateFingerprint(context);\n      if (verified.fingerprint && verified.fingerprint !== currentFingerprint) {\n        throw new Error('Invalid token fingerprint');\n      }\n    }\n\n    const response = this.decodeWithReadableDates(token, verified);\n    this.cacheToken(token, response);\n    return response;\n  }\n\n  /**\n   * Generate a new refresh token with HttpOnly cookie configuration\n   * @param payload Token payload\n   * @param cookieOptions Optional cookie configuration\n   * @returns Token response with cookie configuration\n   */\n  generateRefreshToken(\n    payload: object,\n    cookieOptions?: TokenlyOptions\n  ): TokenlyResponse {\n    this.validatePayload(payload);\n    const finalPayload: { [key: string]: any } = { ...payload };\n    \n    // Eliminar propiedades JWT existentes\n    delete (finalPayload as any).aud;\n    delete (finalPayload as any).iss;\n    delete (finalPayload as any).exp;\n    delete (finalPayload as any).iat;\n\n    const token = jwt.sign(finalPayload, this.secretRefresh, {\n      ...this.jwtOptions,\n      expiresIn: this.refreshTokenExpiry,\n    });\n\n    const response = this.decodeWithReadableDates(token);\n    response.cookieConfig = {\n      name: 'refresh_token',\n      value: token,\n      options: {\n        ...this.cookieOptions,\n        ...cookieOptions,\n      }\n    };\n\n    return response;\n  }\n\n  /**\n   * Verify a refresh token\n   * @param token JWT token string\n   * @returns Verified token response\n   */\n  verifyRefreshToken(token: string): TokenlyResponse {\n    const decoded = jwt.verify(token, this.secretRefresh, this.verifyOptions) as TokenlyToken;\n    return this.decodeWithReadableDates(token, decoded);\n  }\n\n  /**\n   * Rotate access and refresh tokens\n   * @param refreshToken Current refresh token\n   * @param newPayload Optional new payload for the tokens\n   * @returns New access and refresh tokens\n   */\n  rotateTokens(refreshToken: string): {\n    accessToken: TokenlyResponse;\n    refreshToken: TokenlyResponse;\n  } {\n    if (!refreshToken || typeof refreshToken !== 'string') {\n      throw new Error('Invalid refresh token format');\n    }\n\n    const verified = this.verifyRefreshToken(refreshToken);\n    const { iat, exp, aud, iss, ...payload } = verified.payload;\n\n    // Verificar límite de rotaciones\n    const tokenId = refreshToken;\n    const currentCount = this.rotationCounts.get(tokenId) || 0;\n    \n    if (currentCount >= (this.rotationConfig.maxRotationCount || 2)) {\n      throw new Error('Maximum rotation count exceeded');\n    }\n    \n    this.rotationCounts.set(tokenId, currentCount + 1);\n\n    return {\n      accessToken: this.generateAccessToken(payload),\n      refreshToken: this.generateRefreshToken(payload)\n    };\n  }\n\n  /**\n   * Store a token\n   * @param token Token string to store\n   */\n  setToken(token: string): void {\n    this.currentToken = token;\n  }\n\n  /**\n   * Retrieve the stored token\n   * @returns The stored token or null if none exists\n   */\n  getToken(): string | null {\n    return this.currentToken;\n  }\n\n  /**\n   * Clear the stored token\n   */\n  clearToken(): void {\n    this.currentToken = null;\n  }\n\n  /**\n   * Helper para verificar si un token está próximo a expirar\n   * @param token Token a verificar\n   * @param thresholdMinutes Minutos antes de la expiración para considerar como \"próximo a expirar\"\n   */\n  public isTokenExpiringSoon(token: string, thresholdMinutes: number = 5): boolean {\n    try {\n      const decoded = jwt.decode(token) as jwt.JwtPayload;\n      if (!decoded || !decoded.exp) return false;\n\n      const expirationTime = decoded.exp * 1000;\n      const currentTime = Date.now();\n      const timeUntilExpiry = expirationTime - currentTime;\n      \n      return timeUntilExpiry < (thresholdMinutes * 60 * 1000);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Helper para obtener información del token de forma segura\n   * @param token Token a decodificar\n   */\n  public getTokenInfo(token: string): TokenInfo | null {\n    try {\n      const decoded = jwt.decode(token) as jwt.JwtPayload;\n      if (!decoded) return null;\n\n      return {\n        userId: decoded.userId as string,\n        expiresAt: new Date(decoded.exp! * 1000),\n        issuedAt: new Date(decoded.iat! * 1000),\n        fingerprint: decoded.fingerprint as string | undefined\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Validar un token sin verificar la firma (útil para pre-validaciones)\n   * @param token Token a validar\n   */\n  public validateTokenFormat(token: string): boolean {\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) return false;\n\n      return parts.every(part => {\n        try {\n          Buffer.from(part, 'base64').toString();\n          return true;\n        } catch {\n          return false;\n        }\n      });\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Generar un token temporal de un solo uso\n   * @param purpose Propósito del token\n   * @param expiresIn Tiempo de expiración\n   */\n  public generateOneTimeToken(purpose: string, expiresIn: string = '5m'): string {\n    const payload = {\n      purpose,\n      nonce: crypto.randomBytes(16).toString('hex'),\n      iat: Math.floor(Date.now() / 1000)\n    };\n\n    return jwt.sign(payload, this.secretAccess, { expiresIn });\n  }\n\n  /**\n   * Validar un refresh token con verificaciones adicionales de seguridad\n   */\n  public verifyRefreshTokenEnhanced(token: string): TokenlyResponse {\n    if (!this.validateTokenFormat(token)) {\n      throw new Error('Invalid token format');\n    }\n\n    const verified = this.verifyRefreshToken(token);\n    \n    if (this.isTokenExpiringSoon(token, 60)) {\n      throw new Error('Refresh token is about to expire');\n    }\n\n    return verified;\n  }\n\n  // Sistema de eventos\n  public on(event: string, callback: Function): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event)?.push(callback);\n  }\n\n  private emit(event: string, data: any): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners?.length) {\n      listeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          // Silent error handling for callbacks\n        }\n      });\n    }\n  }\n\n  // Sistema de caché con auto-limpieza\n  private cacheToken(key: string, value: TokenlyResponse): void {\n    this.tokenCache.set(key, value);\n    \n    // Auto-limpieza después de 5 minutos\n    setTimeout(() => {\n      this.tokenCache.delete(key);\n    }, 5 * 60 * 1000);\n  }\n\n  // Análisis de seguridad del token\n  public analyzeTokenSecurity(token: string): TokenSecurityAnalysis {\n    const decoded = jwt.decode(token, { complete: true }) as { \n      header: { alg: string }, \n      payload: TokenlyToken & { fingerprint?: string } \n    };\n    if (!decoded) throw new Error('Invalid token');\n\n    return {\n      algorithm: decoded.header.alg,\n      hasFingerprint: !!decoded.payload.fingerprint,\n      expirationTime: new Date(decoded.payload.exp * 1000),\n      issuedAt: new Date(decoded.payload.iat * 1000),\n      timeUntilExpiry: (decoded.payload.exp * 1000) - Date.now(),\n      strength: this.calculateTokenStrength(decoded)\n    };\n  }\n\n  // Calcular la fortaleza del token\n  private calculateTokenStrength(decodedToken: any): 'weak' | 'medium' | 'strong' {\n    let score = 0;\n    \n    // Verificar algoritmo\n    if (decodedToken.header.alg === 'HS512') score += 2;\n    else if (decodedToken.header.alg === 'HS256') score += 1;\n    \n    // Verificar fingerprint\n    if (decodedToken.payload.fingerprint) score += 2;\n    \n    // Verificar tiempo de expiración\n    const timeUntilExpiry = (decodedToken.payload.exp * 1000) - Date.now();\n    if (timeUntilExpiry < 15 * 60 * 1000) score += 1; // < 15 minutos\n    else if (timeUntilExpiry < 60 * 60 * 1000) score += 2; // < 1 hora\n    \n    return score <= 2 ? 'weak' : score <= 4 ? 'medium' : 'strong';\n  }\n\n  // Rotación automática de tokens\n  public enableAutoRotation(options: AutoRotationOptions = {}): NodeJS.Timeout {\n    console.log('Enabling auto rotation...');\n    const {\n      checkInterval = 50,\n      rotateBeforeExpiry = 1000\n    } = options;\n\n    if (this.autoRotationInterval) {\n      clearInterval(this.autoRotationInterval);\n    }\n\n    // Ejecutar verificación inmediata\n    this.checkTokensExpiration(rotateBeforeExpiry);\n\n    // Configurar nuevo intervalo\n    this.autoRotationInterval = setInterval(() => {\n      this.checkTokensExpiration(rotateBeforeExpiry);\n    }, checkInterval);\n\n    return this.autoRotationInterval;\n  }\n\n  // Método para detener la auto-rotación\n  public disableAutoRotation(): void {\n    if (this.autoRotationInterval) {\n      clearInterval(this.autoRotationInterval);\n      this.autoRotationInterval = null;\n    }\n  }\n\n  private checkTokensExpiration(rotateBeforeExpiry: number): void {\n    Array.from(this.tokenCache.entries()).forEach(([token, _]) => {\n      try {\n        const decoded = jwt.decode(token) as jwt.JwtPayload;\n        if (decoded?.exp) {\n          const timeUntilExpiry = (decoded.exp * 1000) - Date.now();\n          if (timeUntilExpiry < rotateBeforeExpiry) {\n            this.emit('tokenExpiring', {\n              token,\n              userId: decoded.userId,\n              expiresIn: timeUntilExpiry\n            });\n          }\n        }\n      } catch (error) {\n        // Silent error handling for token checks\n      }\n    });\n  }\n\n  // Limpieza automática de tokens revocados\n  public enableAutoCleanup(interval: number = 3600000): void { // 1 hora por defecto\n    setInterval(() => {\n      const now = Date.now();\n      this.revokedTokens.forEach(token => {\n        try {\n          const decoded = jwt.decode(token) as jwt.JwtPayload;\n          if (decoded && decoded.exp && decoded.exp * 1000 < now) {\n            this.revokedTokens.delete(token);\n          }\n        } catch {\n          // Token inválido, eliminarlo\n          this.revokedTokens.delete(token);\n        }\n      });\n    }, interval);\n  }\n\n  private handleDeviceStorage(userId: string, fingerprint: string): void {\n    if (!this.deviceTokens.has(userId)) {\n      this.deviceTokens.set(userId, new Set());\n    }\n\n    const userDevices = this.deviceTokens.get(userId)!;\n    const deviceKey = `${userId}:${fingerprint}`;\n\n    if (!this.fingerprintCache.has(deviceKey)) {\n      if (userDevices.size >= this.securityConfig.maxDevices) {\n        throw new Error('Maximum number of devices reached');\n      }\n      this.fingerprintCache.set(deviceKey, fingerprint);\n    }\n\n    userDevices.add(fingerprint);\n  }\n}\n\n// Tipos adicionales\ninterface TokenInfo {\n  userId: string;\n  expiresAt: Date;\n  issuedAt: Date;\n  fingerprint?: string;\n}\n\ninterface TokenSecurityAnalysis {\n  algorithm: string;\n  hasFingerprint: boolean;\n  expirationTime: Date;\n  issuedAt: Date;\n  timeUntilExpiry: number;\n  strength: 'weak' | 'medium' | 'strong';\n}\n\ninterface AutoRotationOptions {\n  checkInterval?: number;\n  rotateBeforeExpiry?: number;\n}","import { Headers } from '../types.js';\n\n/**\n * Helper function to get the real client IP from various headers\n * @param headers Object containing HTTP headers\n * @param defaultIP Optional default IP if no headers found\n * @returns string Client IP address\n */\nexport function getClientIP(headers: Headers, defaultIP?: string): string {\n    // Intentar X-Real-IP primero\n    const realIP = headers['x-real-ip'];\n    if (typeof realIP === 'string' && realIP.trim()) {\n        return realIP.trim();\n    }\n\n    // Fallback a X-Forwarded-For si está disponible\n    const forwardedFor = headers['x-forwarded-for'];\n    if (typeof forwardedFor === 'string' && forwardedFor.trim()) {\n        return forwardedFor.split(',')[0].trim();\n    }\n\n    // Último fallback a IP proporcionada o vacía\n    return defaultIP || '';\n}"],"names":["Tokenly","constructor","config","this","currentToken","blacklistedTokens","Set","deviceTokens","Map","rotationCounts","revokedTokens","autoRotationInterval","fingerprintCache","instanceId","crypto","randomBytes","toString","secretAccess","process","env","JWT_SECRET_ACCESS","generateSecret","secretRefresh","JWT_SECRET_REFRESH","console","warn","accessTokenExpiry","ACCESS_TOKEN_EXPIRY","refreshTokenExpiry","REFRESH_TOKEN_EXPIRY","cookieOptions","httpOnly","secure","NODE_ENV","sameSite","path","maxAge","jwtOptions","algorithm","issuer","audience","verifyOptions","algorithms","clockTolerance","rotationConfig","enableAutoRotation","rotationInterval","maxRotationCount","securityConfig","enableFingerprint","enableBlacklist","maxDevices","revokeOnSecurityBreach","eventListeners","tokenCache","type","createHash","update","Date","now","digest","formatDate","timestamp","toISOString","decodeWithReadableDates","token","decoded","jwt","decode","iat","exp","payloadWithoutDates","raw","payload","undefined","generateFingerprint","context","userAgent","trim","ip","Error","normalizedUA","toLowerCase","replace","normalizedIP","combinedData","revokeToken","add","emit","userId","error","isTokenBlacklisted","has","validatePayload","Object","keys","length","prototype","hasOwnProperty","call","entries","forEach","key","value","JSON","stringify","generateAccessToken","options","finalPayload","fingerprint","handleDeviceStorage","sign","expiresIn","response","cacheToken","verifyAccessToken","verified","verify","ignoreExpiration","currentFingerprint","generateRefreshToken","aud","iss","cookieConfig","name","verifyRefreshToken","rotateTokens","refreshToken","tokenId","currentCount","get","set","accessToken","setToken","getToken","clearToken","isTokenExpiringSoon","thresholdMinutes","expirationTime","currentTime","getTokenInfo","expiresAt","issuedAt","validateTokenFormat","parts","split","every","part","Buffer","from","generateOneTimeToken","purpose","nonce","Math","floor","verifyRefreshTokenEnhanced","on","event","callback","push","data","listeners","setTimeout","delete","analyzeTokenSecurity","complete","header","alg","hasFingerprint","timeUntilExpiry","strength","calculateTokenStrength","decodedToken","score","log","checkInterval","rotateBeforeExpiry","clearInterval","checkTokensExpiration","setInterval","disableAutoRotation","Array","_","enableAutoCleanup","interval","userDevices","deviceKey","size","getClientIP","headers","defaultIP","realIP","forwardedFor"],"mappings":"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"}